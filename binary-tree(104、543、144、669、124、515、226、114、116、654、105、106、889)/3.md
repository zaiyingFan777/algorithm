## 二叉树（构造篇）（参考链接：https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247496574&idx=1&sn=87d6f6bb23c7bdc30828797a361ac8c1&scene=21#wechat_redirect）

本文是承接 二叉树（纲领篇） 的第二篇文章，先复述一下前文总结的二叉树解题总纲：

> 二叉树解题的思维模式分两类：
> 1. **是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个traverse函数配合外部变量来实现，这叫「遍历」的思维模式。
> 2. **是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。  
> 无论使用哪种思维模式，你都需要思考：  
> **如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

第一篇文章 二叉树（思维篇） 讲了「遍历」和「分解问题」两种思维方式，本文讲二叉树的构造类问题。

**二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树**。

接下来直接看题。

### 构造最大二叉树

先来道简单的，这是力扣第 654 题「最大二叉树」，题目如下：

![](3-1.jpg)

函数签名如下：

```
TreeNode constructMaximumBinaryTree(int[] nums);
```

每个二叉树节点都可以认为是一棵子树的根节点，对于根节点，首先要做的当然是把想办法把自己先构造出来，然后想办法构造自己的左右子树。

所以，我们要遍历数组把找到最大值maxVal，从而把根节点root做出来，然后对maxVal左边的数组和右边的数组进行递归构建，作为root的左右子树。

按照题目给出的例子，输入的数组为[3,2,1,6,0,5]，对于整棵树的根节点来说，其实在做这件事：

```
TreeNode constructMaximumBinaryTree([3,2,1,6,0,5]) {
  // 找到数组中的最大值
  TreeNode root = new TreeNode(6);
  // 递归调用构造左右子树
  root.left = constructMaximumBinaryTree([3,2,1]);
  root.right = constructMaximumBinaryTree([0,5]);
  return root;
}
```

再详细一点，就是如下伪码：

```
TreeNode constructMaximumBinaryTree(int[] nums) {
  if (nums is empty) return null;
  // 找到数组中的最大值
  int maxVal = Integer.MIN_VALUE;
  int index = 0;
  for(int i = 0; i < nums.length; i++) {
    if (nums[i] > maxVal) {
      maxVal = nums[i];
      index = i;
    }
  }

  TreeNode root = new TreeNode(maxVal);
  // 递归调用构造左右子树
  root.left = constructMaximumBinaryTree([0..index-1]);
  root.right = constructMaximumBinaryTree([index+1..nums.length-1]);
  return root;
}
```

**当前nums中的最大值就是根节点，然后根据索引递归调用左右数组构造左右子树即可**。

明确了思路，我们可以重新写一个辅助函数build，来控制nums的索引：

```
/* 主函数 */
TreeNode constructMaximumBinaryTree(int[] nums) {
  return build(nums, 0, nums.length - 1);
}

// 传数组下标范围，而不切割数组，是个不错的思路
// 定义：将Nums[0..hi]构成符合条件的树，返回根节点
TreeNode build(int[] nums, int lo, int hi) {
  // lo == hi的时候说明有一个元素
  if (hi < lo) {
    return null;
  }

  // 找到数组中的最大值和对应的索引
  int index = -1, maxVal = Integer.MIN_VALUE;
  for(int i = lo; i <= hi; i++) {
    if (nums[i] > maxVal) {
      maxVal = nums[i];
      index = i;
    }
  }

  // 先构造根节点
  TreeNode root = new TreeNode(maxVal);
  // 递归调用构造左右子树
  root.left = build(nums, lo, index - 1);
  root.right = build(nums, index + 1, hi);
  return root;
}
```

至此，这道题就做完了，还是挺简单的对吧，下面看两道更困难一些的。