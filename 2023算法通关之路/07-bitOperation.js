// 第七章 位运算
/*计算机中的数据都是以二进制的形式存储的，二进制的运算都是按位来进行的。以整数为例，位运算就是直接对整数在内存中的二进
制位进行操作，效率比算术运算要高。例如，求一个数的2倍的值，使用位运算比算术运算要快很多，因为算术运算的乘法指令所用的指令
周期（指令周期是指CPU从内存取出一条指令并执行这条指令的时间总和）比[位运算的移位指令]所用的指令周期长。*/

/*既然计算机内部的计算都是二进制的位运算，那么若将位运算应用到算法题中会发生什么呢？实际上，很多问题从[位的角度思考]都会
变得更加简单、清晰明了，能够直达问题本质。下面的题目都可以选择不使用位运算的方法解决，但是相比之下，位运算有效率高、符合
问题本质、简单明了等优点。只是位运算的算法一般不容易被想到，需要勤加练习。*/

/* 位运算包括取反、按位或、按位异或、按位与、移位等操作。常见的位运算符如下。
1.取反（~）：按位取反，1变0，0变1。
2.按位或（|）：操作位中只要有1，则结果为1；否则结果为0。
3.按位异或（^）：操作位中只要有两位相反（一个为1，一个为0），则结果为1；否则结果为0。ps: 相反为1 相同为0
---------------------------------------------------------------------------------------------
1 ^ 2
1 对应的二进制是 --> 0000 0000 0000 0000 0000 0000 0000 0001
2 对应的二进制是 --> 0000 0000 0000 0000 0000 0000 0000 0010
由于前30位相比较全部为0，这里就比较后两位
-- 0 1 --
-- 1 0 --
---------
-- 1 1 --   // 二进制补齐32位，转换成十进制后，结果为3
---------------------------------------------------------------------------------------------
4.按位与（&）：操作位中只要有两位全部为1，则结果为1；否则结果为0。
5.移位（<<或>>）：移位分为算术移位和逻辑移位；根据移位方向又分为左移运算和右移运算。ps: <<左移，>>右移*/

/*位运算在面试中，经常是几个运算联合起来才能解题，但单一的位运算经常用到特定的解题步骤中，例如按位与（&）运算通常用来查
看某个特定的位是否为1（如7.1节的题目）；又如移位运算可以快速实现一个整数除以2的操作(ps: (3+1)>>1 => 2)。*/

// 7.1 位1的个数
// 191-hammingWeight

// 解法一 循环和位移动
// 思路
/*
  最直接的思路是检测无符号整数的每一个比特位是否是1。如果检测的比特位是1，则计数器加1。检测比特位是否为1的方法为利用掩码
（掩码是用一串二进制代码对目标字段进行位与运算，此处的二进制代码串为1，目标字段为待检测位）与待检测整数，采用位与操作（&）。
*/
/* 
  以0000 0000 0000 0000 0000 0000 0000 1011为例，将其与掩码1执行按位与操作，得到最低有效位的数值，值非0，计数器加1。使用
  左移运算得到检测第i位值的掩码（1 << i），将掩码与待检测整数做按与操作，值非0，计数器加1，否则计数器不变。重复这个过程直到1
  移动到最高位，检测完待检测整数的所有数据位。
*/

/*
  复杂度分析
  时间复杂度：O(1)，因为是整数，所以执行32次操作，即可检测所有的位。
  空间复杂度：O(1)，无须额外分配空间。
*/

/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
  // 示例过程
  // 0b1011 & 0b0001 => 1 count++ 左移0
  // 0b1011 & 0b0010 => 2 count++ 左移1
  // 0b1011 & 0b0100 => 0         左移2
  // 0b1011 & 0b1000 => 8 count++ 左移3
  // 按4位算，共计循环了4次，左位移了3次，其实可以位移4次第一次位移0位还是其本身
  // 掩码
  var mask = 1;
  // 1的个数
  var count = 0;
  var i = 0;
  while(i < 32) {
    // 每次mask左移i位
    if ((n & (mask << i)) !== 0) {
      count++;
    }
    i++;
  }
  return count;
};

// 解法二 (解法一的优化)
// 思路
/*
  就解法一的代码实现来说，针对任意的整数，都要执行32次的移位和与操作，如果整数比较小，比如7（用二进制表示为0b0111），不
  仅最低的4位需要进行移位和按位与操作，其他位也要继续进行同样的位操作，但这些操作是冗余的，是可以优化的。
  优化上面的算法，使其更简单，速度更快。不去检测整数的每一位，而是依次将最低位且值为1的比特位翻转为0，并增加计数器。当
  执行结果使整数为0时，该整数不再包含任何为1的比特，返回计数器的值。
  此时的关键问题是如何执行“翻转最低有效比特为1的比特为0”，此处可以使用n & (n-1)的操作。
 */
// 见图片 ./images/01-hammingWeight.jpg
// 如上图所示，在整数n的二进制码中，最低有效比特为1的位置，在对应的n-1中，该位置总是0，因此执行与操作时会将该比特的1翻转为0，并且不会改变其他比特的值。

/**
 * 复杂度分析
 * 时间复杂度：O(1)。
 * 空间复杂度：O(1)。
 */

// 代码
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
  // 思路：32位进行32次的左移位与操作，当比如7(0b0111)时，低位的4位需要移位和按位与，高位的都用不到，因此这些操作是冗余的
  // 优化：反转最低有效比特为1的比特位0，通过n & (n - 1)
  // 示例：
  // 0b1111(15，总共有四个位为1)
  // 1.第一次 15 & 14 => 0b1110 去掉了一个低位的1
  //   0b1111
  //  &0b1110
  // ->0b1110 得到14 
  // 2.第二次 14 & 13 => 0b1100 (12) 去掉了一个低位的1
  //  0b1110
  // &0b1101 
  //->0b1100 得到12
  // 3.第三次 12 & 11 => 0b1000 (8) 去掉了一个低位的1
  //  0b1100
  // &0b1011
  //->0b1000 得到8
  // 4.第四次 8 & 7 => 0b0000 (0) 去掉了最后一个1
  //  0b1000 
  // &0b0111
  //->0b0000 得到0
  var count = 0;
  while(n) {
    // 循环结束条件为0，每次n & (n-1)都会去掉一个低位的1
    n &= (n - 1);
    count++;
  }
  return count;
}

// 7.2 实现加法
// 371-getSum
/**
 * 思路：
 * 该题目的要求是：如何在不使用算术运算符的情况下，实现加法运算。可以考虑的方法只能是位运算，而位运算的操作是针对二进制数的。
 * 此时就要首先考虑，在熟悉的十进制中，加法运算是如何实现的；其次，由十进制推广到n进制的加法运算规律是什么；最后使用二进制总结出来的n进制的规律即可。
 * 
 * 在十进制中，加法运算的实现原理是[两个加数的相同位和上一位的进位相加]，如果和小于10，不产生进位；如果和大于10，则保留最低有效位，将进位向上加1。
 * 从两个加数的最低位（个位）开始，依次循环至加数的最高位。
 * 
 * 将上面的十进制加法实现原理，推广到n进制，同样地，只需要注意两个加数必须是n进制表示的即可。最后再考虑二进制的加法，只需要把两个加数用二进制表示即可。
 * 
 * 看一下二进制表示中每一位的加法运算的4种情况。
 * 1.0+0=00（原位为0，向前无进位）。
 * 2.0+1=01（原位为1，向前无进位）。
 * 3.1+0=01（原位为1，向前无进位）。
 * 4.1+1=10（原位为0，向前进位1）。
 * 
 * 从上面的情况可以看出，在二进制中两个加数相同位的相加结果，主要分为两部分：两个加数相同位相加后的原位值，以及两个加数相同位相加后的进位值。
 * 相加后的原位值的规律为如果两个加数不同，则结果为1；如果两个加数相同，则结果为0。正好符合位运算的异或操作(^)。
 * 相加后的进位值的规律为当两个加数相同位都为1时，结果为1；否则结果为0。正好符合位运算的与运算。
 * 
 * 根据上面的分析，用位操作实现加法运算，总结如下。
 * 1.a+b等于相加后的原位值+进位值
 * 2.使用异或操作，计算出两个加数的二进制表示中相加后的原位值。
 * 3.使用与操作和移位操作，计算出两个加数的二进制表示中相加后的进位值。
 * 4.循环上面的过程，直至进位值为0。
 */

/**
 * 复杂度分析
 * 时间复杂度：O(1)。因为整数最多需要32位的二进制表示，最多循环32次，所以时间复杂度是固定的。
 * 空间复杂度：O(1)。
 */
//  <<左移，>>右移
/**
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var getSum = function(a, b) {
  // 先找计算规律
  // 0+0=00
  // 0+1=01
  // 1+0=01
  // 1+1=10
  // 总结两条规律1.原位相加满足^(异或)的操作2.进位满足&操作符(两个加数同位都为1，则结果为1，否则为0)
  // 因此我们可以
  // 示例：0b0110 + 0b0111
  // 1.第一次循环
  // 我们先计算出a+b的进位值
  //  0b0110
  // &0b0111 => 0b0110(6)，0b0110 << 1(左移) 变为12 (0b1100)(ps: 从低位数，第二位，第三位相加确实需要进位为 0b110x)
  // 使用异或计算出两个加数的二进制表述相加后的原位值
  //  0b0110
  // ^0b0111 => 0b0001
  // a = 0b0001，b = carry = 0b1100
  // 2.第二次循环
  // 我们先计算a+b的进位值
  //  0b0001
  // &0b1100 => 0b0000(0,不需要进位)，0b0000 << 1(左移)变为0
  // 使用异或计算出两个加数的二进制表述相加后的原位值
  //  0b0001
  // ^0b1100 => 0b1101 得到计算值 13
  // 示例：0b0101110(46)、0b0111001(57)
  // 1.第一次循环
  // c =  0b0101110
  //     &0b0111001 => 0b0101000(40) 40 << 1 => 80(0b1010000)
  //      0b1010000
  // a = a ^ b
  //     0b0101110
  //    ^0b0111001 => 0b0010111(23)
  // b = c = 80
  // 2.第二次循环
  // c =  0b0010111
  //     &0b1010000
  //   => 0b0010000(16) 16 << 1 => 32(0b0100000)
  // a = a ^ b
  //     0b0010111
  //    ^0b1010000
  //  => 0b1000111(71)
  // b = c = 32(0b0100000)
  // 3.第三次循环
  // c =  0b1000111
  //     &0b0100000
  //    =>0b0000000 (0)
  // a = a ^ b
  //     0b1000111
  //    ^0b0100000
  //   =>0b1100111(103)
  // 循环结束，b=c=0
  while(b !== 0) {
    // 进位
    var carry = (a & b) << 1;
    // 进位后 之前两个数相加的原位值
    a = a ^ b;
    b = carry;
  }
  return a;
};

// 7.3整数替换
// 397-integerReplacement

// 1.递归法(这里迭代法不如递归好处理，因此选择递归)
/**
 * 思路：
 * 从题目描述很容易看出，可以直接套用递归法，当n为1时，直接返回0；如果n大于1，看n是奇数还是偶数。若是偶数则只有一种可能性，就是用n / 2来代替，替换次数计数器加1；
 * 如果n是奇数，则分为n+1和n-1两种情况，选择较小的那一种。具体算法如下。
 * 1.当n是偶数时，直接用n / 2替换n，然后计数器加1。
 * 2.当n是奇数时，分别计算n+1和n-1的最小替换整数次数，使用较小的那个。
 * 3.当最终的终止条件是n=1时，则跳出计算，一路返回。
 */
/**
 * @param {number} n
 * @return {number}
 */
var integerReplacement = function(n) {
  // 递归的出口
  if (n === 1) return 0;
  if (n % 2 === 0) {
    // 偶数
    return integerReplacement(n / 2) + 1;
  } 
  // 奇数
  return Math.min(integerReplacement(n - 1), integerReplacement(n + 1)) + 1;
};

// 2.位操作法
/**
 * 思路
 * 在上面的递归法中，self.integerReplacement(n+1)和self.integerReplacement(n-1)再继续划分，可能会出现重复的运算，比如当n等于13时，12(n-1)和14(n+1)递归的下一层就都包含了6的计算。
 * 为此，我们还需要继续寻找规律，找到能够直接确定使用n+1还是n-1的方法。
 * 对于n是偶数的情况，直接用n / 2 是最优的，理由和解法一中所解释的一样。
 * 对于n是奇数的情况，它的二进制码的最低两位，有两种情况：01和11。
 * 1.如果n的二进制码后两位是01，则n减1。
 * 2.如果n的二进制码后两位是11，则n加1。
 * 3.对于特殊情况，如果n等于3，那么应该减1。
 * 对于二进制码中后两位是11的情况，可以使用(n+1)% 4==0 来表示，考虑到位运算要比取余运算的效率更高，可以使用n & 0x03==0x03代替。
 */

/**
 * 复杂度分析
 * 时间复杂度：O(logn)。
 * 空间复杂度：O(1)。
 */

/**
 * @param {number} n
 * @return {number}
 */
var integerReplacement = function(n) {
  if (n === 1) return 0;
  var count = 0;
  // 当为3的时候是特殊情况，1.是3+1=4 4/2=2 2/1=1 3次 2.是3-1=2，2/1=1 2次
  while(n > 3) {
    if ((n & 1) === 0) {
      // 0b0100 & 1 为0  偶数
      // 0b0101 & 1 为1  奇数
      // 偶数情况
      // https://blog.csdn.net/qq_44606064/article/details/114698020
      // （1）>> ,<<表示算数移位，移动时要考虑符号位（下面举例都是默认带符号位，最左边位符号位）
      //   1101（-3）算术右移1位 1110（-2）； 1101（-3）算术左移1位 11010（-6）
      //   010（2）算术右移1位001（1）； 010（2）算术左移1位0100（4）；

      // （2） >>>,<<<表示逻辑移位,整体左右移，缺位补0（下面举例都是默认带符号位，最左边位符号位）
      //  1101逻辑右移1位 0110； 1101逻辑左移1位 1010
      //  010逻辑右移1位001； 010逻辑左移1位100；
      n >>>= 1; 
    } else if ((n & 3) === 3) {
      // 奇数情况
      // 后两位为11的，则 (0b0011 & 3) === 3 后两位为01的 & 3不为3 
      // 如果n的二进制后两位为11，则加一
      n += 1;
    } else {
      // 奇数情况
      // 如果n的二进制后两位是01则减一
      n -= 1;
    }
    count++;
  }
  if (n === 3) {
    // 3的话 3-1=2 count为1，2/1=1 count为2次
    return count + 2
  } else {
    // 假设n为2，我们直接走这里，上面的while不会进入，
    return count + 1;
  }
};

// 7.4 只出现一次的数字
// 136-singleNumber

// 解法一 哈希表法
/**
 * 思路
 * 要想找到只出现1次的元素，只需要将所有元素统计一遍，并记录每个元素出现的次数，找到统计次数为1的元素即可。为了统计元素出现的次数，这里使用哈希表数据结构。算法步骤具体如下。
 * 1.遍历数组中的所有元素，并设置键值对。
 * 2.返回只出现了1次的元素。
 * 复杂度分析
 * 1.时间复杂度：O(n)，n为数组的长度。
 * 2.空间复杂度：O(n)，n为数组的长度。
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
  var countHashMap = new Map();
  // 遍历nums，将nums[i]为key，以及nums[i]出现的次数为val存起来
  for(var num of nums) {
    countHashMap.set(num, (countHashMap.get(num) || 0) + 1);
  }
  // 遍历countHashMap
  // set遍历的话，也用for of 只有一个val字段
  for(var [key, val] of countHashMap) {
    if (val === 1) {
      return key;
    }
  }
};

// 解法二 异或法
//  0b0010
// ^0b0010
//  0b0000
/**
 * 思路：
 * 数组中只有一个数是只出现1次的，其他数都能找到与之相等的数值。题目中给出了信息“除某个元素只出现1次外，其余每个元素均出现2次”，如果能有一种方法，对于出现2次的数，
 * 让它们相抵消，那么最后就会只剩下出现1次的元素，即为我们要找的元素。
 * 让相等的两个数相抵消，一种方法是使用算术运算符，两数相减；一种是使用位运算符做异或运算（a ^ a = 0）。因为我们无法知道具体哪两个元素相等，所以算术运算符法行不通，
 * 而执行异或操作，则不需要知道哪两个元素相等，只要最后将所有元素均执行异或操作即可。
 * 异或操作的运算逻辑是，如果同一位的数字相同，则为0，不同则为1。两个数字异或（a ^ b）的结果是将a和b的二进制码每一位进行运算得出的数字。相等数值的一个特点是两数异或后为0。
 * [因为异或操作符合交换律，即a ^ b ^ a == a ^ a ^ b]，因此可以将数组中所有的数做异或操作，这样就可以将相等的数都筛掉（a ^ b ^ a == a ^ a ^ b == b），剩余的值即为我们要找的只出现1次的元素。
 * 
 * 复杂度分析
 * 1. 时间复杂度：O(n)，n为数组的长度。
 * 2. 空间复杂度：O(1)。
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
  var res = 0; // 0 ^ 任何数 = 任何数 
  // 2 ^ 2 ^ 1 === 1 ^ 2 ^ 2 === 1 
  var i = 0;
  while(i < nums.length) {
    res ^= nums[i];
    i++;
  }
  return res;
}

// 解法三 数学法
/**
 * 假设数组有a、a、b、b、c几个元素，由数学法计算2 *(a+b+c)-(a+a+b+b+c)=c。
 * 复杂度分析
 * 1.时间复杂度：O(n)，n为数组的长度。
 * 2.空间复杂度：O(n)，n为数组的长度。
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
  // 求和
  var sumNums = nums.reduce((a, b) => a + b, 0);
  // 数组去重
  var deduplicatedNums = Array.from(new Set(nums));
  // 数组去重之后的和
  var sumDeduplicatedNums = deduplicatedNums.reduce((a, b) => a + b, 0);

  return 2 * sumDeduplicatedNums - sumNums;
}

// 题目扩展Ⅰ 137-singleNumber
/**
 * 思路1：
 * 上面的题目提到“其余每个元素均出现2次”，基于这一点，我们才可以使用异或法，如果“其余每个元素均出现3次”呢？这就变成了力扣（LeetCode）中的第137题，题目描述如下。
 * 给定一个非空整数数组，除某个元素只出现1次外，其余每个元素均出现了3次。找出那个只出现了1次的元素。(说明如果要求算法具有线性时间复杂度，你可以不使用额外空间来实现吗？)
 * 此时哈希表法仍然可以解题，思路与上面的解法一一致。
 * 数学法同样适用，因为3(a+b+c)-(a+a+a+b+b+b+c)=2c，此时只要将上面的数学法中的算式除以2即可，即return(3 * sum(set(nums))-sum(nums))// 2。
 * 上面的解法二中的简单异或法，无法筛选出唯一的单一元素，因为异或法无法将3个元素消除，但考虑到在元素的二进制形式中，对于出现3次的元素，它的二进制形式中的每一位都是3的倍数，
 * 统计所有数字的二进制形式中1出现的次数，并对3求余，如果结果不为0，则说明出现1次的数字在该二进制位上为1。以题目中给出的示例[2,2,3,2]为例，思路如下图所示。
 * 见图片./07-images/02-singleNumber.jpg
 */
/**
 * 复杂度分析
 * 时间复杂度：O(n)。上面虽然使用了双重循环，但由于内层循环次数是常数，所以时间复杂度仍为O(n)，其中n为数组长度。
 * 空间复杂度：O(1)。
 */
// map、数学法忽略
// 这里用二进制的位运算
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
  // 定义counts数组，长度为32模拟32位
  var counts = new Array(32).fill(0);
  // 遍历nums，将nums中的每一个元素的每一位是1的在counts[i]+1，注意counts数组0就是Num中的最小的那一位
  for(var num of nums) {
    // 拿到每一个num
    for(var i = 0; i < 32; i++) {
      // 这里判断每一位是不是1用& 1 是否为1
      counts[i] += (num & 1);
      // 将num右移动1位，这样counts中的下标1就是num中的第二小的哪一位
      // 1.0b1111 => counts[0] = 1 => [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] 
      // 2.0b0111 => counts[1] = 1 => [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] 
      // 3.0b0011 => counts[2] = 1 => [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] 
      // 3.0b0001 => counts[3] = 1 => [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ....以此类推
      num >>= 1;
    }
  }
  // m对每位%3的3
  var [res, m] = [0, 3];
  // 得到counts数组后，我们需要对每一位%3 看余数是否为0，因为三个数0b0010和0b0011 得到counts[0]为1 counts[1]为4，然后4%3 = 1, 1%3 = 1，这样的到11(3)，3就是唯一的值
  // 从最高位开始，对每位%3，最高位就是counts[31]，然后对res << 1左移一位这样就可以求第二高位的数，0 |= 1 => 1; 0 |= 0 => 0，以此类推最低位在最后
  for(var j = 31; j >= 0; j--) {
    res <<= 1;
    res |= (counts[j] % m);
  }
  // 需要注意的是，如果使用的语言对「有符号整数类型」和「无符号整数类型」没有区分，那么可能会得到错误的答案。这是因为「有符号整数类型」（即 int 类型）的第 31 个二进制位（即最高位）是补码意义下的符号位，对应着 −2^31
  // ，而「无符号整数类型」由于没有符号，第 31 个二进制位对应着 2^31。因此在某些语言（例如 Python）中需要对最高位进行特殊判断。
  // javascript中默认都是带符号的整数，注意是整数，总共32位（含符号位）。
  // java 有符号31位，第32个位最高位就是符号位
  // public static void main(String[] args) {
  //   int test = 0b01111111111111111111111111111111;
  //   int test2 = 0b10000000000000000000000000000000;
  //   int test3 = 0b10000000000000000000000000000001;
  //   int test4 = 0b11111111111111111111111111111111;
  //   System.out.println(test); // 2147483647
  //   System.out.println(test2); // -2147483648
  //   System.out.println(test3); // -2147483647
  //   System.out.println(test4); // -1
  // }
  // js
  // var test = 0b01111111111111111111111111111111; // 2147483647
  // var test2 = 0b10000000000000000000000000000000; // 2147483648 转为了无符号位
  // var test3 = 0b10000000000000000000000000000001; // 2147483649 转为了无符号位
  // var test4 = 0b11111111111111111111111111111111; // 4294967295 转为了无符号位
  // js超出带符号表示默认转成无符号表示
  return res; // (counts[31] % m === 0) ? res : ~(res ^ 0xffffffff); python写法（32位为无符号位）
};


// 题目扩展Ⅱ 260-singleNumber
/**
 * 继续扩展，修改上面的条件，将第136题中的除某个元素只出现1次以外改为其中恰好有两个元素只出现1次。得到力扣（LeetCode）中的第260题，题目描述如下。
 * 给定一个整数数组nums，其中恰好有两个元素只出现1次，其余所有元素均出现2次，找出只出现1次的那两个元素。
 * 示例:
 * 输入：[1,2,1,3,2,5]
 * 输出：[3,5]
 * 此时使用哈希表法仍然可以解题，思路与上面的解法一一致，此处略去不讲；而数学法在这里不再适用，因为我们无法通过上面的数学公式区分两个出现1次的数。
 * 
 * 但是这道题仍然可以采用异或的思路去解决。首先进行一次全员异或操作，得到的结果就是那两个只出现1次的两个不同的数字的异或结果。异或运算规律中有一条是任何数和本身异或结果都为0，
 * 因此可以将这两个不同的数字分到两个组A和B中。分组需要满足两个条件。
 * 1.两个独特的数字分到不同组。
 * 2.相同的数字分到相同组。
 * 这样每一组的数分别进行异或，即可得到那两个数字。问题的关键是怎样进行分组呢？由异或的性质同一位相同则为0，不同则为1，可知将所有数字异或的结果一定不是0，也就是说至少有一位是1。
 * 我们随便取一个，分组的依据就出来了。依据就是你取的那一位是0的分到一组，是1的分到另外一组。
 * 这样肯定能保证上述第2条“相同的数字分到相同组”，那么两个独特的数字会被分成不同组么？
 * 很明显可以，因为我们选择的那一位是1，也就是说两个独特的数字在被选取的二进制位上一定是不同的，因此两个独特的元素一定会被分到不同组。
 * 
 * 复杂度分析
 * 时间复杂度：O(n)，n为数组的长度。
 * 空间复杂度：O(1)。
 */
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var singleNumber = function(nums) {
  var res = 0;
  // 返回值
  var a = 0, b = 0;
  // 1.依然将所有的num进行^，这样得到两个没有重复值的a、b的异或结果res; nums = [1,2,1,3,2,5] => res = 6
  for(var num of nums) {
    res ^= num;
  }
  // ps:
  //  0b0011 3
  // ^0b0101 5
  //=>0b0110 由此可见3^5的结果不为0，肯定有一位结果为1(0b0110中的第二个位以及第三个位是1，说明3、5的第二、三个位都是不同的)，说明这俩数是不同的，因此我们拿mask也就是异或出来结果第一个位1的位（这里是2）
  // 通过按位与来分组，
  // 2.异或的结果res，从最低位开始，找到第一个为1的位，用来接下来的分组; 1. 0b0110 & 0b0001 === 0, mask <<= 1得到 2, 2.0b0110 & 0b0010 !== 0，所以mask为2
  var mask = 1;
  while((res & mask) === 0) {
    // 低位没有就继续向上一位去寻找
    mask <<= 1;
  }
  // 3.得到mask(2)就是res中从低位开始第一个为1的值，我们根据mask去分组，让nums中的每个num按位与mask，这样的就可以将相同的num分组到一起，并且a、b这俩唯一数还杯分到不同的组
  // ps: [1,2,1,3,2,5]每个元素按位与mask分成俩组 [1, 1, 5] [2, 3, 2]这样1.相同的数字分到相同的组、2.两个独特的数字分到不同组
  for(var num of nums) {
    if ((num & mask) === 0) {
      a ^= num;
    } else {
      b ^= num;
    }
  }
  return [a, b];
};
