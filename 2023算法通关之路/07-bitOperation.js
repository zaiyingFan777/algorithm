// 第七章 位运算
/*计算机中的数据都是以二进制的形式存储的，二进制的运算都是按位来进行的。以整数为例，位运算就是直接对整数在内存中的二进
制位进行操作，效率比算术运算要高。例如，求一个数的2倍的值，使用位运算比算术运算要快很多，因为算术运算的乘法指令所用的指令
周期（指令周期是指CPU从内存取出一条指令并执行这条指令的时间总和）比[位运算的移位指令]所用的指令周期长。*/

/*既然计算机内部的计算都是二进制的位运算，那么若将位运算应用到算法题中会发生什么呢？实际上，很多问题从[位的角度思考]都会
变得更加简单、清晰明了，能够直达问题本质。下面的题目都可以选择不使用位运算的方法解决，但是相比之下，位运算有效率高、符合
问题本质、简单明了等优点。只是位运算的算法一般不容易被想到，需要勤加练习。*/

/* 位运算包括取反、按位或、按位异或、按位与、移位等操作。常见的位运算符如下。
1.取反（~）：按位取反，1变0，0变1。
2.按位或（|）：操作位中只要有1，则结果为1；否则结果为0。
3.按位异或（^）：操作位中只要有两位相反（一个为1，一个为0），则结果为1；否则结果为0。ps: 相反为1 相同为0
---------------------------------------------------------------------------------------------
1 ^ 2
1 对应的二进制是 --> 0000 0000 0000 0000 0000 0000 0000 0001
2 对应的二进制是 --> 0000 0000 0000 0000 0000 0000 0000 0010
由于前30位相比较全部为0，这里就比较后两位
-- 0 1 --
-- 1 0 --
---------
-- 1 1 --   // 二进制补齐32位，转换成十进制后，结果为3
---------------------------------------------------------------------------------------------
4.按位与（&）：操作位中只要有两位全部为1，则结果为1；否则结果为0。
5.移位（<<或>>）：移位分为算术移位和逻辑移位；根据移位方向又分为左移运算和右移运算。*/

/*位运算在面试中，经常是几个运算联合起来才能解题，但单一的位运算经常用到特定的解题步骤中，例如按位与（&）运算通常用来查
看某个特定的位是否为1（如7.1节的题目）；又如移位运算可以快速实现一个整数除以2的操作(ps: (3+1)>>1 => 2)。*/

// 7.1 位1的个数
// 191-hammingWeight

// 解法一 循环和位移动
// 思路
/*
  最直接的思路是检测无符号整数的每一个比特位是否是1。如果检测的比特位是1，则计数器加1。检测比特位是否为1的方法为利用掩码
（掩码是用一串二进制代码对目标字段进行位与运算，此处的二进制代码串为1，目标字段为待检测位）与待检测整数，采用位与操作（&）。
*/
/* 
  以0000 0000 0000 0000 0000 0000 0000 1011为例，将其与掩码1执行按位与操作，得到最低有效位的数值，值非0，计数器加1。使用
  左移运算得到检测第i位值的掩码（1 << i），将掩码与待检测整数做按与操作，值非0，计数器加1，否则计数器不变。重复这个过程直到1
  移动到最高位，检测完待检测整数的所有数据位。
*/

/*
  复杂度分析
  时间复杂度：O(1)，因为是整数，所以执行32次操作，即可检测所有的位。
  空间复杂度：O(1)，无须额外分配空间。
*/

/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
  // 示例过程
  // 0b1011 & 0b0001 => 1 count++ 左移0
  // 0b1011 & 0b0010 => 2 count++ 左移1
  // 0b1011 & 0b0100 => 0         左移2
  // 0b1011 & 0b1000 => 8 count++ 左移3
  // 按4位算，共计循环了4次，左位移了3次，其实可以位移4次第一次位移0位还是其本身
  // 掩码
  var mask = 1;
  // 1的个数
  var count = 0;
  var i = 0;
  while(i < 32) {
    // 每次mask左移i位
    if ((n & (mask << i)) !== 0) {
      count++;
    }
    i++;
  }
  return count;
};

// 解法二 (解法一的优化)
// 思路
/*
  就解法一的代码实现来说，针对任意的整数，都要执行32次的移位和与操作，如果整数比较小，比如7（用二进制表示为0b0111），不
  仅最低的4位需要进行移位和按位与操作，其他位也要继续进行同样的位操作，但这些操作是冗余的，是可以优化的。
  优化上面的算法，使其更简单，速度更快。不去检测整数的每一位，而是依次将最低位且值为1的比特位翻转为0，并增加计数器。当
  执行结果使整数为0时，该整数不再包含任何为1的比特，返回计数器的值。
  此时的关键问题是如何执行“翻转最低有效比特为1的比特为0”，此处可以使用n & (n-1)的操作。
 */
// 见图片 ./images/01-hammingWeight.jpg
// 如上图所示，在整数n的二进制码中，最低有效比特为1的位置，在对应的n-1中，该位置总是0，因此执行与操作时会将该比特的1翻转为0，并且不会改变其他比特的值。

/**
 * 复杂度分析
 * 时间复杂度：O(1)。
 * 空间复杂度：O(1)。
 */

// 代码
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
  // 思路：32位进行32次的左移位与操作，当比如7(0b0111)时，低位的4位需要移位和按位与，高位的都用不到，因此这些操作是冗余的
  // 优化：反转最低有效比特为1的比特位0，通过n & (n - 1)
  // 示例：
  // 0b1111(15，总共有四个位为1)
  // 1.第一次 15 & 14 => 0b1110 去掉了一个低位的1
  //   0b1111
  //  &0b1110
  // ->0b1110 得到14 
  // 2.第二次 14 & 13 => 0b1100 (12) 去掉了一个低位的1
  //  0b1110
  // &0b1101 
  //->0b1100 得到12
  // 3.第三次 12 & 11 => 0b1000 (8) 去掉了一个低位的1
  //  0b1100
  // &0b1011
  //->0b1000 得到8
  // 4.第四次 8 & 7 => 0b0000 (0) 去掉了最后一个1
  //  0b1000 
  // &0b0111
  //->0b0000 得到0
  var count = 0;
  while(n) {
    // 循环结束条件为0，每次n & (n-1)都会去掉一个低位的1
    n &= (n - 1);
    count++;
  }
  return count;
}
