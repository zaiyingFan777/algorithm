// 力扣（LeetCode）中与游戏相关的题目有很多，它们场景各异，从问题角度可以分为求解和博弈两大类。
// 本章专注于求解。

// 4.1-外观数列（报数）
// 38-countAndSay
// 思路1：迭代法
// 这道题目的英文标题为count and say，直译过来是计算并报数，与外观数列的描述相比，作者认为前者要形象许多。这是一种并不复杂的报数游戏，根据题意，11被读作“two 1s”(两个一），即21；
// 21被读作“one 2，one 1”（一个二，一个一)，即1211，每次报数产生的新的字符串由原字符串的每个字符及其计数拼接构成。
// 从1到n的过程需要逐次报数，每次报数又需要从头到尾遍历上一次报数的结果，因此在这里使用双重循环是顺理成章的。
// 1.内层循环实现报数，即字符拼接过程。遍历数列，使用变量current_char和char_count记录正在报数的数字和出现次数。
// 1.1 如果当前数字和正在记录的数字一致，增加计数。
// 2.1 否则就进行一次报数，即将被记录数字和出现次数拼接在临时结果序列tmp中，同时将记录的数字替换为当前数字，将计数设置为1。
// 2.外层循环负责为下一次报数提供新的数列，并进行中间变量的初始化
// 2.1 初始化tmp、current_char、char_count，并在内层循环结束时为末尾的数字进行一次报数。
// 2.2 将结果记录到ans中。
// 2.3 循环的最后一轮，被保存的结果就是我们需要的答案
// 复杂度分析
// 时间复杂度：计算规模随着迭代次数n及每次计算得到的字符串长度的变大而变大，因此时间复杂度为O(mn)，m为最后一次计算时的字符串长度。
// 空间复杂度：O(m)，m为最后一次计算时的字符串长度。
// 代码
/**
 * @param {number} n
 * @return {string}
 */
var countAndSay = function(n) {
  // 1为base case
  var ans = "1";
  // 比如n为2，我们只需要遍历1次，当n为1的时候默认base case 1
  // 外层循环决定循环次数，以及初始化temp、currentChar、charCount等，提供下一轮循环的的新数列ans
  for(var i = 1; i < n; i++) {
    var temp = "";
    // 当前的字符串
    var currentChar = ans[0];
    var charCount = 0;
    // 内层循环
    var lenAns = ans.length;
    // 内层循环计算charCount以及更新temp、charCount等
    for(var j = 0; j < lenAns; j++) {
      if (ans[j] === currentChar) {
        charCount++;
      } else {
        temp += `${charCount}${currentChar}`;
        charCount = 1;
        currentChar = ans[j];
      }
      // 写到外循环也可以
      // if (j === lenAns - 1) {
      //   // 到最后了
      //   temp += `${charCount}${currentChar}`;
      //   ans = temp;
      // }
    }
    temp += `${charCount}${currentChar}`;
    ans = temp;
  }
  return ans;
};

// 解法2 递归法
// 下面换一种思路，先不考虑具体如何报数，从1到n的数列产生逻辑很好地体现了递归思想。假设报数，即字符的拼接过程为函数do_string，我们可以很快得到递归解法的雏形。
// ----------------------------------------------
// function countAndSay(n) {
//   var preStr = countAndSay(n - 1);
//   // 拼接字符串
//   var curStr = doString(preStr);
//   return curStr;
// }
// ----------------------------------------------
// 剩下要做的无非是实现字符拼接逻辑do_string：依照题意遍历字符串，以当前记录中的字符为基准，遇到相同字符时记录字符个数；遇到不同的字符时打印计数和字符，并替换记录的字符；继续遍历直
// 至末尾。
// 与前面已经列出的递归框架结合，我们可以很快地完成这道题目的解答。
// 复杂度分析
// 递归次数随着输入值n的增加而增加，每次计算的规模随着字符串previous_string的变长而变大，因此时间复杂度为O(mn)，m为最后一次计算的字符串长度。
// 空间复杂度：由于使用了递归，递归函数的参数n每次减少1，因此空间复杂度为O(n+m)，m为最后一次计算时的字符串长度。
// 代码：
/**
 * @param {number} n
 * @return {string}
 */
var countAndSay = function(n) {
  var doString = function(s) {
    // 根据s得到新的字符串
    var ans = "";
    var curChar = s[0];
    var curCount = 0;
    for(var i = 0; i < s.length; i++) {
      if (curChar === s[i]) {
        curCount++;
      } else {
        ans += `${curCount}${curChar}`;
        curChar = s[i];
        curCount = 1;
      }
    }
    ans += `${curCount}${curChar}`;
    return ans;
  }
  if (n === 1) return "1";
  // 找到前一个字符串
  var preStr = countAndSay(n - 1);
  // 根据preStr得到现在的字符串
  var curStr = doString(preStr);
  return curStr;
}

// 4.2 24点
// 679-judgePoint24
// 解法1 回溯递归法
// 思路：
// 4张牌加上四则运算，为拼出24点我们需要对这些数字和运算规则进行排列组合，如示例1中，输入数组为[4,1,8,7]，一种解法是将数字重新排列为8,4,7,1，同时先后进行（8-4）、（7-1）及两者的乘法。
// 由此不难看出针对此游戏，我们是可以穷举出所有潜在结果并得到答案的，穷举的过程可以分两步进行。
//   1.计算4个数字的全排列，如果有重复数字应当去重。
//   2.针对每一种排列计算所有可能的结果，与24进行比对。
// 数字的排列组合
//   学习过排列组合的读者应该知道，n个数字的全排列一共有n!个，其推理也并不复杂：选择排列中的第1个数字时有n种选择，选择第2个数字时因为已经用掉了一个，那么还剩n– 1种选择，以此类推，直至
// 最后一个位置的可选数字只有一个，将所有的可能性相乘就得到了最终的结果。
//   如果使用计算机程序实现上述过程，最适合的算法思想是什么呢？答案是回溯法，从第1位开始逐位放入数字，得到某个排列之后，如果它不是最后一个解（或者在题目的限定条件下不是正确解），回
// 溯算法会回到上一步做一些改变，即回溯并再次尝试，直至覆盖所有可能的路径。
//   当存在相同数字时，全排列可能出现重复，去重可以减少不必要的计算。寻找排列前先对数字进行排序，回溯时遇到前后数字重复且前边数字已经尝试过的情况就跳过计算过程。当然去重并不是必需
// 的，如果去重增加的额外计算成本高于带来的收益的话，也可以不进行优化。

// 注意事项
// 对于大多数编程语言中，浮点数并不能完全精确地表示十进制数，并且即使是最简单的数学运算也可能引起一定的误差
// a = 3.2 
// b = 2.1
// a + b = 5.300000000000001
// (a + b) === 5.3 => false
// 因此在对计算结果进行比较时，需要考虑避免上述问题的出现，在比较24点时我们采取了下面的做法。
// abs(nums[0] - 24) <= 0.000001(1e-6)

// ---------------------------------------------------------------------------------------
// Leetcode官方解答
// 一共有 4 个数和 3 个运算操作，因此可能性非常有限。一共有多少种可能性呢？
// 首先从 4 个数字中有序地选出 2 个数字，共有 4×3=12 种选法，并选择加、减、乘、除 4 种运算操作之一，用得到的结果取代选出的 2 个数字，剩下 3 个数字。
// 然后在剩下的 3 个数字中有序地选出 2 个数字，共有 3×2=6 种选法，并选择 4 种运算操作之一，用得到的结果取代选出的 2 个数字，剩下 2 个数字。
// 最后剩下 2 个数字，有 2 种不同的顺序，并选择 4 种运算操作之一。
// 因此，一共有 12×4×6×4×2×4=9216 种不同的可能性。
// 可以通过回溯的方法遍历所有不同的可能性。具体做法是，使用一个列表存储目前的全部数字，每次从列表中选出 2 个数字，再选择一种运算操作，用计算得到的结果取代选出的 2 个数字，这样列表中的数字就减少了 1 个。
// 重复上述步骤，直到列表中只剩下 1 个数字，这个数字就是一种可能性的结果，如果结果等于 24，则说明可以通过运算得到 24。如果所有的可能性的结果都不等于 24，则说明无法通过运算得到 24。
// 实现时，有一些细节需要注意。
//   1.除法运算为实数除法，因此结果为浮点数，列表中存储的数字也都是浮点数。在判断结果是否等于 24 时应考虑精度误差，这道题中，误差小于 10^-6 可以认为是相等。
//   2.进行除法运算时，除数不能为 0，如果遇到除数为 0 的情况，则这种可能性可以直接排除。由于列表中存储的数字是浮点数，因此判断除数是否为 0 时应考虑精度误差，这道题中，当一个数字的绝对值小于 10^-6 时，可以认为该数字等于 0。
// 还有一个可以优化的点。
//   1.加法和乘法都满足交换律，因此如果选择的运算操作是加法或乘法，则对于选出的 2 个数字不需要考虑不同的顺序，在遇到第二种顺序时可以不进行运算，直接跳过。
// ---------------------------------------------------------------------------------------
// 复杂度分析
// 时间复杂度：O(1)。一共有 9216 种可能性，对于每种可能性，各项操作的时间复杂度都是 O(1)，因此总时间复杂度是 O(1)。
// 空间复杂度：O(1)。空间复杂度取决于递归调用层数与存储中间状态的列表，因为一共有 4 个数，所以递归调用的层数最多为 4，存储中间状态的列表最多包含 4 个元素，因此空间复杂度为常数。
/**
 * @param {number[]} cards
 * @return {boolean}
 */
var judgePoint24 = function(cards) {
  var target = 24;
  var epsilon = 1e-6; // 0.000001
  // 加、乘、减、除 首先加、乘满足交换交换律，我们把加、乘放在最前面
  var add = 0, multiply = 1, subtract = 2, divide = 3;
  // solve: 解决
  var solve = function(list) {
    var n = list.length;
    // base case 
    if (n === 0) return false;
    // 当长度为1的时候，需要判断是否等于24
    if (n === 1) {
      // 这道题中当一个数字的绝对值小于 10^-6 时，可以认为该数字等于 0
      return Math.abs(list[0] - target) < epsilon;
    }
    // ps: 为何两次for循环因为我们计算需要两个数以及符号一次for循环，我们回退也是在符号的for循环里
    // 挑一个数
    for(var i = 0; i < n; i++) {
      // 再挑一个数
      for(var j = 0; j < n; j++) {
        // 避免i j 重复
        if (i !== j) {
          // 定义一个新的list2
          var list2 = [];
          // 将非i j的其他元素放入到list2中
          for(var k = 0; k < n; k++) {
            if (k !== i && k !== j) {
              list2.push(list[k]);
            }
          }
          // 选择计算符号 + * - / 
          for(var m = 0; m < 4; m++) {
            // 注意：加法、乘法满足交换律 
            // i > j是为了判定交换律的成立，如果i < j,说明是第一次做加或乘运算
            if (m < 2 && i > j) {
              continue;
            }
            // 加
            if (m === add) {
              // list2从两个变为三个，第三个是计算的结果
              list2.push(list[i] + list[j]);
            }
            // 乘
            if (m === multiply) {
              list2.push(list[i] * list[j]);
            }
            // 减
            if (m === subtract) {
              list2.push(list[i] - list[j]);
            }
            // 除
            if (m === divide) {
              // 注意除数（分母）不能为0
              if (Math.abs(list[j]) < epsilon) {
                continue;
              } else {
                list2.push(list[i] / list[j]);
              }        
            }
            // 至此已经由4→3，进入下一层由3→2的过程，依次类推
            if (solve(list2)) {
              return true;
            }
            // 回退
            // 没凑成24就把加到list2末尾的结果数删掉，考虑下种运算可能
            list2.pop();
          }
        }
      }
    }
    return false;
  }
  return solve(cards);
};

// 4.3 数独游戏(回溯算法记得写好base case以及return的出口，做选择的时候可以通过if(backtrack(xxx)){return true})
// 37-solveSudoku
// 解法：回溯解法
// 思路:
// 算法的核心思路非常简单，就是对着每个空着的格子穷举1到9，如果遇到不合法的数字（在同一行或同一列或同一个3*3的区域中存在相同的数字）则跳过，如果找到一个合法的数字，则继续穷举下一个空格子。
// 难点：递归出口 1.这一行结束了 2.行数>9。 3.3*3宫格如何判断是否有重复的数字
// 时间复杂度：假设每个空格可能填入的数字个数都是m，算法的最差时间复杂度为O(mn)；在实际情况下，每个格子的m应介于1到9之间，且并不一定相同，具体的最长的执行时间为所有m值的乘积。
// 空间复杂度：解题过程中所使用的中间变量与棋盘的大小有关，在大小固定的棋盘上，算法的空间复杂度为O(1)。

// 代码
/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solveSudoku = function(board) {
  // 9行、9列
  var m = board.length, n = board[0].length;
  // 校验九宫格是否符合规则
  var isValid = function(board, r, c, ch) {
    // r行、c列
    for(var i = 0; i < 9; i++) {
      // 检查本行是否有重复
      if (board[r][i] === ch) return false;
      // 检查本列是否有重复
      if (board[i][c] === ch) return false;
      // 判断3*3方框是否存在重复
      // 这里是以board[r][c]为起点 往右 往下
      // [r c]   [r c+1] [r c+2]
      // [r+1 c] [r+1 c+1] [r+1 c+2]
      // [r+2 c] [r+2 c+1] [r+2 c+2]
      if (board[Math.floor(r/3)*3 + Math.floor(i/3)][Math.floor(c/3)*3 + i%3] === ch) return false;
    }
    return true;
  }
  // 回溯核心代码
  // i代表行、j代表列
  var backtrack = function(board, i, j) {
    // base case
    // 如果本行遍历完
    if (j === n) {
      // 去下一行
      return backtrack(board, i + 1, 0);
    }
    // 如果行数用完，说明找到了合适的
    if (i === m) {
      return true;
    } 
    // 需要先检查i、j是否还在范围内，再判断是否本格是否有值
    // 判断这个board[i][j]如果存在数则跳出
    if (board[i][j] !== '.') {
      return backtrack(board, i, j + 1);
    }
    // 核心遍历，每次选择1-9然后下个宫格接着选，不对则撤销选择
    for(var ch = 1; ch <= 9; ch++) {
      // 做选择前，先检查是否合法
      if (!isValid(board, i, j, ch.toString())) {
        // 不合法跳过本轮循环
        continue;
      }
      // 做选择
      board[i][j] = ch.toString();
      // 继续下一层选择
      if (backtrack(board, i, j + 1)) {
        return true;
      }
      // 回撤选择
      board[i][j] = '.';
    }
    // 如果结束 说明没有合适的
    return false;
  }
  // 执行回溯
  backtrack(board, 0, 0);
}

// 4.4 生命游戏
// 289-gameOfLife
// 思路
// 题目对具体场景和生存条件的描述非常清楚，因此实现思路也有章可循，根据题目分析实现的重点。
//   ● 计算细胞邻居个数，即8个相邻位置存在的细胞数。
//   ● 根据计算结果决定每个细胞的生死状态，即0或1。
// 先来看一下细胞邻居个数的计算。根据数组下标连续的特点，使用当前细胞的坐标值计算出邻居细胞的位置获取状态，如当前细胞为board[i][j]，则其上边的邻居为board[i-1][j]，右边的邻居为
// board[i][j+1]；因为空间有限的设定，计算时需要注意边界条件，当细胞处在空间边缘、顶点位置时潜在邻居的数目会小于8个。定义top、bottom、left、right 等4个变量对取值范围进行预处理，当邻
// 居的坐标超出给定数组范围时移动边界。如下面的代码所示。
// top = max(0, i - 1)
// bottom = min(len(board) - 1, i + 1)
// left = max(0, j - 1)
// right = min(len(board[0]) - 1, j + 1)
// 得到邻居细胞数量之后，我们要借助它判定并更新细胞的状态。根据设定，在每轮游戏中，所有细胞要同时更新状态，因此无法在一次遍历中完成判定与更改，我们将这个过程分为两个步骤。
//   ● 遍历所有细胞计算邻居细胞的数量，根据生存法则判定并记录下一回合对应的状态。
//   ● 状态判定完成后，重新遍历所有细胞依照记录更新状态。
// 基于上述分析，我们已经能够进行基本的实现了，题目还有进阶的条件限定，要求我们使用原地算法，这意味着在第一步不能使用额外的数组存放下一回合状态的记录。
// 为避免在标记过程中使用1和0两个状态影响后续细胞的遍历，约定使用-1表示当前回合为1且下一回合应变为0的状态，使用-2表示当前回合为0且下一回合应变为1的状态；
// 相应地，在进行邻居细胞计算时，遇到-1也认为当前该位细胞为存活状态，虽然下一回就会死亡。
// 完成所有状态的判定后，再进行一次遍历，将-1和-2设置为0和1，这道题目就完美解决了。下面是基于上面思路实现的js代码。

// ------------------------------------------------
// 本题的难点在于寻找周边的8个点以及可能存在的越界情况
// 本题突破点 本题只需要找每个细胞周围的活细胞即可
// ------------------------------------------------

// 复杂度分析
// 时间复杂度：由循环遍历的方法可以得出时间复杂度为O(mn)，m和n分别为board数组的行数、列数。
// 空间复杂度：采用原地算法，空间复杂度为O(1)

// 代码
/**
 * @param {number[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var gameOfLife = function(board) {
  // m行、n列
  var m = board.length, n = board[0].length;
  // 获取周边活的细胞的数量
  var getNeighborCount = function(i, j, board) {
    // 定位四个点 上下左右
    var top = Math.max(0, i - 1); 
    // var bottom = Math.min(board.length - 1, i + 1);
    var bottom = Math.min(m - 1, i + 1);
    var left = Math.max(0, j - 1);
    // var right = Math.min(board[0].length - 1, j + 1);
    var right = Math.min(n - 1, j + 1);
    // 符合的个数
    var count = 0;
    // 上下、左右、对角线
    // 外部循环从上到下，内部循环从左到右，正好覆盖上面的8种情况
    for(var r = top; r <= bottom; r++) {
      for(var c = left; c <= right; c++) {
        // 排除自己
        if (r === i && c === j) {
          continue;
        }
        if (board[r][c] === 1 || board[r][c] === -1) {
          count++;
        }
      }
    }
    return count;
  }
  // 定义：-1为活的变为死的
  // -2为死的变为活的
  // 第一次遍历找到下一次应该出现的状态
  // 行的遍历
  for(var i = 0; i < m; i++) {
    // 列的遍历
    for(var j = 0; j < n; j++) {
      // 找到周围活的细胞数量
      var neighborLiveCount = getNeighborCount(i, j, board);
      if (board[i][j] === 1) {
        // // 活细胞
        // if (neighborLiveCount < 2) {
        //   board[i][j] = -1;
        // }
        // if (neighborLiveCount === 2 || neighborLiveCount === 3) {
        //   board[i][j] = 1;
        // }
        // if (neighborLiveCount > 3) {
        //   board[i][j] = -1;
        // }
        if (neighborLiveCount >= 2 && neighborLiveCount <= 3) {
          board[i][j] = 1;
        } else {
          board[i][j] = -1;
        }
      }
      if (board[i][j] === 0) {
        // 当前为死细胞
        if (neighborLiveCount === 3) {
          board[i][j] = -2;
        }
      }
    }
  }
  // 第二次遍历：将临时状态修改
  for(var i = 0; i < m; i++) {
    // 列的遍历
    for(var j = 0; j < n; j++) {
      // 我们规定: -1为1变为0的临时状态，-2为0变1的临时状态
      if (board[i][j] === -1) {
        board[i][j] = 0;
      }
      if (board[i][j] === -2) {
        board[i][j] = 1;
      }
    }
  }
};