// 第六章 二分法
// 二分法是一种常用的算法，主要包括原始二分查找及实现难度更大的二分变种。二分法是分治思想的体现，它与分治法的区别在于分
// 治法是将一个复杂的问题不断分解成几个规模更小的子问题，直至子问题可以直接求解；而二分法则是不断地通过比较操作将问题规模缩
// 小一半，直至找到目标元素。

// 6.1 二分查找
// 407-search
// 思路
// 一个直接的想法是遍历数组，依次考虑每个元素是否等于target。这样做的时间复杂度是O(n)，但如果遇到超过107大小的数据规模将会超时，显然不是题目所要考查的算法。
// 重新审视题目给定的条件，数组是有序的，“有序”或许蕴藏着某种规律，可以用来提高算法的效率。当查找范围为[l,h]时，观察一下中间元素nums[mid]和目标值target之间的关系（l表示左边界low，
// h表示右边界high，mid表示中间位置，后面将不再进行解释）。
// 1.如果nums[mid]大于target，则nums[mid]右侧的所有元素也会大于target（数组的有序性，元素从左到右递增），target必定存在于nums[mid]的左侧，下次查找时就可以将范围缩小为nums[l]到
// nums[mid-1]，即查找区间减小了一半。
// 2.如果nums[mid]小于target，则nums[mid]左侧的所有元素也会小于target（数组的有序性，元素从左到右递增），target必定存在于nums[mid]的右侧，下次查找时就可以将范围缩小为 nums[mid+1]
// 到nums[h]，即查找区间减小了一半。
// 3.如果nums[mid]等于target，则已经找到所需要的目标值，可结束查找。
// 如下图所示，一开始的查找区间为[1,2,3,4,5]。由于中间元素3小于目标值5，则下次的查找区间更新为[4,5]。
// 见图 ./06-images/06-search.jpg

// 证明一 数学法
// 初始的问题规模为n，每次搜索的时候可以将当前问题划分为原来的一半，则整个问题规模的变化为(n/2^1, n/2^2, n/2^3, n/2^4…(, n/2^k 。每次划分问题即验证中间元素的操作只需要O(1)；
// 而问题规模的变化次数k在最坏情况下，需要将问题规模缩小到1才找到目标元素，问题规模n与变化次数k的关系为2k=n,k =logn。
// 因此，总的时间复杂度为验证中间元素的操作时间×问题规模的变化次数=O(logn)。

// 证明二 绘图法
// 见图 ./06-images/06-search2
// 将整个搜索的区域看成一个二叉搜索树，对于每一个节点，左子树的所有节点值都会小于右子树的所有节点值。设定搜索的起点为根节点，也就是当前搜索区域的中间节点。如果根节点为目标值，则结
// 束搜索；如果根节点不是目标值，根据数据结构的有序性，以及目标值与根节点的大小关系，选择左子树（目标值小于根节点）或右子树（目标值大于根节点）作为下次搜索的区域，并重复上述操作。
// 在最坏情况下，根节点一直不是目标值，最终会搜索到二叉搜索树的叶子节点。从原始的根节点算起，其经过的长度为二叉树的高度H，而由于其是一个二叉搜索树，树的高度H等于logn，显然总的时间复杂度为
// O(logn)。


// 复杂度分析
// 时间复杂度：O(logn)，其中n是数组长度。
// 空间复杂度：O(1)。

// 代码
// 查找nums数组中元素值为target的下标，如果不存在，则返回-1
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
  var n = nums.length;
  var l = 0, h = n - 1;
  // [l, h]左闭右闭区间，循环退出条件 l > h
  while(l <= h) {
    var mid = (l + h) >> 1;
    if (nums[mid] < target) {
      l = mid + 1;
    } else if (nums[mid] > target) {
      h = mid - 1;
    } else {
      return mid;
    }
  }
  return -1;
};

// 小结
// 二分法的一个常见应用场景就是有序数组这类结构的查找。当题目涉及有序或查找时，我们可以尝试用二分法进行思考，并且思考的方向是中间元素是否和周围元素存在某种关联，以及如何利用中间元
// 素来缩小问题规模。

// 6.2 寻找旋转排序数组中的最小值
// 153-findMin
// 思路
// 由于题目涉及查找，且数组在旋转前是有序的，因此可以往二分法方向思考。
// 首先观察一下数组本身所存在的规律，由于原升序数组在某个点进行了旋转，其右侧区域将会与其左侧区域的数组元素对调，使旋转后的数组满足左侧区域的元素都大于右侧区域的元素，且左、右侧区
// 域的元素是有序的。
// 当查找范围为l到h时，中间元素nums[mid]和最后一个元素的关联，以及最小值可能存在的区域范围如下。
// 1. 如果nums[mid]大于最后一个元素，则nums[mid]属于左侧区域（旋转后左侧元素大于右侧元素），最小值在[mid+1,h]中，更新左边界l为mid+1。
// 2. 如果nums[mid]小于最后一个元素，则nums[mid]属于右侧区域（右侧元素递增），最小值在[l,mid]中，nums[mid]可能是最终答案，但不能直接排除，更新右边界h为mid。
// 3. 如果l等于h，查找元素只剩下一个l，则数组中的最小值为nums[l]。
// 完善
// 进一步思考，与上一题相比，查询的中间元素变得不确定，以往能够通过直接比对判断某个元素是否符合题目要求，而现在缺少直接判断的条件（mid==target）。幸运的是，我们还是能够通过二分法不
// 断地缩小最终答案可能存在的区间，当区间只剩下一个元素时（l==h），那么它就是最终答案。

// 二分法中有一种类型是查找最左（最右）满足条件的值，这也运用了类似的思想，即在找到满足条件的一个候选答案时，不是直接返回，而是贪心地继续查看是否还有其他答案。例如要在一个数组
// [1,2,2,3,4]中找最左边的等于2的值，当我们找到索引值为2的项时，不能直接返回，而是继续贪心地搜索区间，将右边的区间舍弃并继续查看左侧是否还有另外一个2。关于这一点，后面的第875题爱吃香蕉
// 的珂珂会继续进行讲解

// 代码
// 复杂度分析
// 时间复杂度：O(logn)，其中n是数组长度
// 空间复杂度：O(1)。
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
  var n = nums.length;
  var l = 0, h = n - 1;
  // 有序数组二分，我们可以通过nums[mid]与target去比较，但是我们数组一部分被反转了就会导致[4,5,1,2,3]，但是这样依然可以使用二分，我们可以通过
  // nums[mid]与最右边的去比较, 最右边的元素有个特点: 无论旋转多少次，最右边的元素为旋转后右侧递增子序列的最大值，因此我们就可以跟他作比较，mid > target，mid在左侧区间
  // 最小值在[mid+1, h], mid < target，mid在最右侧区间，最小值在[l, mid]之间
  var target = nums[h];
  while(l <= h) {
    // 这里拿nums[mid]与最右边的去比较
    var mid = (l + h) >> 1;
    if (l === h) {
      // 当l与h重合的时候，就是最小值
      return nums[l];
    } else if (nums[mid] < target) {
      // nums[mid] < 最右边的数，说明mid为右侧区间[4,5,1,2,3]从1开始到最右边这样的递增区间内，最小值在[l, mid]中, 这时候我们需要将h值变为mid，因为mid很可能为最小值，
      // 为何不能是从[mid, h]范围，因为mid可能不是最小值，这样可能会被漏掉，因此让[l, mid]这样才对
      h = mid;
    } else if (nums[mid] > target) {
      // [4,5,1,2,3]: l=0,h=4,mid=2 nums[mid] < target => l=0,h=2; mid = 1, nums[mid] > target, l = mid + 1; l = 2 h = 2 l=2就是最小值
      // nums[mid] > target，说明nums[mid]在左侧区间，最小值在[mid+1, h]中
      l = mid + 1;
    }
  }
  return -1;
};

// 小结
// 二分法的使用条件并不局限于有序数组，它只是一种特例。从本质上来说，如果每次都可以使用某种策略来验证中间元素（验证可以视为找规律），并将下次查找的范围缩小一半，那么就可以使用二分法

// 6.3 爱吃香蕉的珂珂（找左侧边界）
// 875-minEatingSpeed
// 思路
// 抛开一切背景，将视线放在题目所要求的目标上——最小的速度k。
// 由于每小时最多只能吃一堆香蕉，速度最多达到最大堆的数量即可，因此，速度的范围为[1,max(piles)]，也就是答案一定在这个范围内。
// 综上，这道题可以看作在[1,max(piles)]中查找一个元素k。因此一个简单的思路是枚举从1到max(piles)的所有速度，并判断是否可以
// 吃完，返回最早能够吃完的速度即可。注意在从1到max(piles)进行枚举的过程中，速度是单调递增变化的，这很容易让我们联想到前面的题目。
// 具体来说，当我们在[l,h]中判断中间的速度mid是否可行时，有如下可能。
// 1.mid不可行，则速度不够快，最小速度位于[mid+1,h]中，更新左边界l为mid+1。
// 2.mid可行，则可能的最小速度小于或等于mid，最小速度位于[l,mid]中，mid可能是最终答案，但不能直接排除，更新右边界h为mid。
// 3.l等于h，则查找区间只剩下一个l，最小速度等于l。

// 复杂度分析
// 时间复杂度：时间复杂度：O(nlog⁡m)，其中 n 是数组 piles 的长度，m 是数组 piles 中的最大值。需要 O(n) 的时间遍历数组找到最大值 m，二分查找需要执行 O(log⁡m) 轮，
// 每一轮二分查找需要 O(n) 的时间!!!，因此总时间复杂度是 O(nlog⁡m)。
// 空间复杂度：O(1)。

// 代码
/**
 * @param {number[]} piles
 * @param {number} h
 * @return {number}
 */
// [l, h] 左闭右闭区间 循环终止条件l > h
var minEatingSpeed = function(piles, h) {
  // 速度mid，去计算吃完所有堆需要多少时间
  var hoursOfEating = function(speed) {
    var hours = 0;
    for(var pile of piles) {
      hours += Math.ceil(pile / speed);
    }
    return hours;
  }
  // 左边界: 左边界为1，说明我们一小时至少吃1堆，总不能为0不吃
  var l = 1;
  // 先找到速度的右边界，r为piles中的最大值，表示在1小时内能吃完最大堆的香蕉
  var r = 0;
  for(var pile of piles) {
    r = Math.max(r, pile);
  }
  // 找到能够满足h的最小速度，就是找出最左侧边界(满足h的速度的最左边界)
  while(l <= r) {
    var mid = (l + r) >> 1;
    // 计算用Mid速度吃完香蕉需要多少时间，跟h去比较
    var hours = hoursOfEating(mid);
    if (l === r) {
      return l;
    } else if (hours > h) {
      // 如果times大于h，说明速度太慢，我们需要提升速度
      l = mid + 1;
    } else if (hours <= h) {
      // 如果times小于h，说明速度可以，继续寻找左边界
      r = mid;
    }
  }
  return -1;
}

// 左闭右开区间[l, r)，循环终止条件l === h
var minEatingSpeed = function(piles, h) {
  // 速度mid，去计算吃完所有堆需要多少时间
  var hoursOfEating = function(speed) {
    var hours = 0;
    for(var pile of piles) {
      hours += Math.ceil(pile / speed);
    }
    return hours;
  }
  // 左边界: 左边界为1，说明我们一小时至少吃1根，总不能为0不吃
  var l = 1;
  // 先找到速度的右边界，r为piles中的最大值，表示在1小时内能吃完最大堆的香蕉
  var r = 0;
  for(var pile of piles) {
    r = Math.max(r, pile);
  }
  // 构造左闭右开区间
  r += 1;
  // 找到能够满足h的最小速度，就是找出最左侧边界(满足h的速度的最左边界)
  // [l, r) [l, mid) [mid + 1, h)
  while(l < r) {
    var mid = (l + r) >> 1;
    // 计算用Mid速度吃完香蕉需要多少时间，跟h去比较
    var hours = hoursOfEating(mid);
    if (hours > h) {
      // 如果times大于h，说明速度太慢，我们需要提升速度 [mid + 1, h)
      l = mid + 1;
    } else if (hours <= h) {
      // 如果times小于h，说明速度可以，继续寻找左边界 [l, mid) 
      r = mid;
    }
  }
  return l;
}

// 6.4 x的平方根
// 69-mySqrt
// 思路：
// 沿用上面题目的思路，由于x是非负整数，因此x的平方根位于[0,x]中，也就是答案一定在这个范围内。
// 实际上还可以进一步缩小这个解的范围，不过这对解题帮助不大，感兴趣的读者可以自行研究一下。
// 因此，这道题等价于在[0,x]中寻找数值k，使其满足k * k <=x。与上面的题目稍有不同，这里找的是最右满足条件的解。
// 具体来说，当查找范围为[l,h]时，将中间元素mid的平方与x进行比较。
// 1.如果l 等于h，则l是x的平方根。
// 2.如果mid的平方大于x，则数值k在[l,mid-1]中，更新右边界h为mid-1。
// 3.如果mid的平方小于或等于x，则数值k在[mid,h]中，mid可能是最终答案，但不能直接排除，更新左边界l为mid。
// 看起来一切都很正常，但在某些情况下，该算法将会导致死循环，永远无法找到数值k。
// 死循环
// 当x=2时，左边界l为0，右边界h为2。
// 第1次循环：l=0，h=2，中间元素mid=(l+h)/ 2=1，1 的平方小于或等于2，更新左边界l为1。
// 第2次循环：l=1，h=2，中间元素mid=1，1的平方小于或等于2，继续更新左边界l为1。
// 在后面的循环中，左边界将一直保持不变，使程序进入死循环，无法退出。
// 究其原因，当查找范围剩下两个元素时，中间元素mid等于(l+h)/2 即左边界l，此时如果左边界l只更新为等于中间元素mid，则左边界
// 相当于没有改变，查找范围一直不会发生改变。换句话说，对于左边界l的更新，如果每次都更新为mid，则可能会出现死循环，而更新为mid+1则不会，因为查找范围进一步缩小了。
// 一个可行的解决方案是：当查找范围剩下两个元素时，退出循环体，并在两个元素中找到目标答案。
// 完善思路
// 修改上述中间元素mid的平方与x的第一条比较规则：l等于h或l+1等于h，则l或h是x的平方根，最后从二者中挑出正确答案。
// 小结
// 当左边界l向下取整更新为mid时可能产生死循环，可通过在判断查找范围为两个元素时退出来解决。同时，右边界h无论更新为mid或mid-1都不会产生死循环，因为h必定大于mid，查找范围必定缩小。以

// 复杂度分析
// 时间复杂度：O(logn)，其中n的大小等于x。
// 空间复杂度：O(1)。

/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
  var l = 0, h = x;
  // [l, h] 
  while(l <= h) {
    var mid = (l + h) >> 1;
    var midSqrt = mid * mid;
    if (l === h || (l + 1) === h) {
      // 当剩下两个元素的时候可能会出现死循环
      break;
    } else if (midSqrt > x) {
      // mid的平方大于x说明需要缩小右边界
      h = mid - 1;
    } else if (midSqrt <= x) {
      // mid的平方小于或者等于x，小于的时候也可能mid为答案，因此我们缩小左边界
      // x = 2
      // 1.l = 0, high = 2 mid = 1, 1*1 < 2 left更新为1,
      // 2.l = 1, h = 2 mid = 1, 1*1<2 left更新为mid(1)，这时候会出现死循环，因此我们当剩下两个元素的时候需要判断l==h或者l+1==h
      l = mid;
    }
  }
  // 对l, l+1进行选择哪个更合适，如果l+1(h)合适那就l+1，如果不合适那就是l
  return (l + 1) * (l + 1) <= x ? (l + 1) + l;
};

// 6.5 寻找峰值
// 162-findPeakElement
// 思路：
// 这道题的背景是在数组中查找目标值（峰值元素），虽然数组不是有序的，但峰值元素具备某种性质（大于左右相邻值的元素），可以尝试使用二分法。

// 关注中间元素和左右相邻元素的关系，当右相邻元素大于中间元素时，意味着右相邻元素可能是峰值，其大于左边元素的条件已经满足，只要右相邻元素也大于它右边元素即可。

// 顺着右边的方向继续扫描，存在以下两种情况。
// 1.右相邻元素一直大于当前可能的峰值，可能的峰值变化为5,7,8。最后扫描到数组的末尾元素8，由于题目假设nums[n]=-∞，8大于右边元素的条件将会满足，成为一个真正的峰值。
// 见图片./06-images/06-findPeakElement.jpg
// 2.扫描期间出现右相邻元素7小于当前可能的峰值8，则8大于右边元素的条件将得到满足，成为一个真正的峰值。
// 见图片./06-images/06-findPeakElement2.jpg

// 左相邻元素大于中间元素的情况与之同理。


// 进一步扩展
// 通过上述过程，我们可以得到一个结论：当右相邻元素大于中间元素时，右侧区域必定存在峰值，可以排除左侧区域；当左相邻元素大于中间元素时，左侧区域必定存在峰值，可以排除右侧区域。具体
// 实现方式如下。
// 在每次查找的过程中，判断中间元素和相邻元素的关系。
// 1.如果中间元素小于右侧元素，则缩小查找区间为右侧区域。
// 2.如果中间元素小于左侧元素，则缩小查找区间为左侧区域。

// 复杂度分析
// 时间复杂度：O(logn)，其中n为数组的长度。
// 空间复杂度：O(1)。

// 代码
/**
 * @param {number[]} nums
 * @return {number}
 */
// 题眼：我们只需要返回其中一个峰值即可
// [1,2,1,3,5,6,4] 1.l:0 h:7 mid:3 nums[mid] < nums[mid + 1] l = mid+1(4) 2.l:4 h:7 mid:5 return 5
var findPeakElement = function(nums) {
  var n = nums.length;
  var l = 0, h = n - 1;
  // [l, h]
  while(l <= h) {
    var mid = (l + h) >> 1;
    if (nums[mid] < nums[mid + 1] && (mid + 1 < n)) {
      // 如果中间值小于右侧相邻元素，就去右侧区域查看，右侧区域肯定存在因为nums[n]为负无穷大
      l = mid + 1;
    } else if (nums[mid] < nums[mid - 1] && (mid - 1 >= 0)) {
      // 比如 21xxx  当nums[mid]为1左边是2，2肯定大于负无穷 因此左侧区域肯定存在峰值
      h = mid - 1;
    } else {
      // } else if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) {
      // 找到峰值，但是上面这种判断可能会造成[1]这种数组越界
      return mid;
    }
  }
  return -1;
};

// 6.6 分割数组的最大值(把本题类比为：在m天，最小运载量为多少的时候将货物运载完，就是求运载量的左边界)
// 410-splitArray
// 思路
// ----------labuladong-------------
// 简单说，给你输入一个数组 nums 和数字m，你要把 nums 分割成m 个子数组。
// 肯定有不止一种分割方法，每种分割方法都会把 nums 分成 m个子数组，这m个子数组中肯定有一个和最大的子数组对吧。
// 我们想要找一个分割方法，该方法分割出的最大子数组和是所有方法中最大子数组和最小的。请你的算法返回这个分割方法对应的最大子数组和。
// 如何转换为二分搜索？其实这道题可以转换为运输问题，我们稍微改一下题目:
// 你只有一艘货船，现在有若干货物，每个货物的重量是 nums[i]，现在你需要在m 天内将这些货物运走，请问你的货船的最小载重是多少?
// 货船每天运走的货物就是 nums 的一个子数组;在m天内运完就是将 nums 划分成m个子数组;让货船的载重尽可能小，就是让所有子数组中最大的那个子数组元素之和尽可能小。
// ----------labuladong-------------

// 复杂度分析
// 时间复杂度：O(nlogm)，其中n为数组长度大小，m为数组元素之和。
// 空间复杂度：O(1)

// 本题可以理解为一艘货船有n堆货物，nums[i]为第n堆货，我们m(target)天运完，然后求货船的运载量最小的情况
// x为运载量 f(x)为天数，运载量越强天数越小，单调递减，子数组最大值就是运载量
// 本函数根据运载量求运载天数（即切割出数组的个数）
var f = function(nums, x) { // x为运载量
  var target = 0;
  for(var i = 0; i < nums.length;) {
    var tmp = x;
    // 遍历堆数
    while(i < nums.length) {
      // if (tmp < nums[i]) {
      //   // tmp < nums[i]，运载能力不够，我们下一次再运载
      //   break;
      // } else {
      //   tmp -= nums[i];
      // }
      if (tmp >= nums[i]) {
        tmp -= nums[i];
        // i++; ok
      } else {
        break;
      }
      i++;
    }
    // 每次运载量被耗尽，我们让天数++
    target++;
  }
  return target;
}

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var splitArray = function(nums, k) {
  // 本题为求m天运完Nums中的n堆货物的最小运载量，即运载量的左边界
  // 1.构造左闭右开区间[left, right)，当然left运载量的最小值起码能运载nums中每一堆的最大值，意思就是一天起码能运一堆(起码切割一次需要切割出来一个数组)
  // 最大值起码一天能运完所有堆的货物(nums[i])
  var left = 0, right = 1;
  for(var num of nums) {
    left = Math.max(left, num);
    right += num;
  }
  while(left < right) {
    var mid = (left + right) >> 1;
    // [left, mid) [mid + 1, right)
    // 求k天内能运完所有货物运载量的左边界
    if (f(nums, mid) === k) {
      right = mid;
    } else if (f(nums, mid) < k) {
      // 运载能力太强：f函数返回的是天数，我们需要缩小右区间
      right = mid;
    } else if (f(nums, mid) > k) {
      // 运载能力弱，需要提升运载能力
      left = mid + 1;
    }
  }
  return left;
}

// 总结
// 二分法的识别
// 简单的题目能够一眼看出“查找”任务，读者也就可以联想到使用二分法；中等级别或困难级别的题目往往背景复杂，无法马上看出是“查找”任务，需要读者进一步加工并对题目进行转换，利用题目
// 中的已知信息，构建查找的目标，以及目标所在的范围。此外，当题目的数据规模超过(10^7) 时，有较大的可能是二分法类型的题目，这也是一个识别二分法的小技巧。

// 二分法的运用
// 关注查找范围内的中间元素，挖掘背后的规律，往往中间元素和题目的目标值、左右相邻元素及左右边界元素等存在一定的关联，根据这些关联可以将查找范围缩小一半。
// 具体的实现方法包括原始的二分查找及二分查找的变种，二者的实现难度不大，唯一需要注意的是二分查找的变种的边界问题，当更新左边界l=mid时，需要修改循环的退出条件为l+1==h or l==h。