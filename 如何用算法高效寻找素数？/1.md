## 如何用算法高效寻找素数？(学习链接: https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484472&idx=1&sn=ab8e97d0211de37bf6770a63caacc630&scene=21#wechat_redirect)

> 100以内所有的素数有如下25个：2、3、5、7、11、13、17、19、23、29、31、37、41、43、47、53、59、61、67、71、73、79、83、89、97

素数(素数即是质数)的定义很简单，如果一个数如果只能被 1 和它本身整除，那么这个数就是素数。(ps: 质数的定义：一个大于1的自然数，除了1和它本身外没有其它的约数)

不要觉得素数的定义简单，恐怕没多少人真的能把素数相关的算法写得高效。本文就主要聊这样一个函数：

```
// 返回区间[2, n)中有几个素数
int countPrimes(int n)

// 比如countPrimes(10)返回4
// 因为 2，3，5，7是素数
```

你会如何写这个函数？当然可以这样写：

```
int countPrimes(int n) {
    int count = 0;
    for(int i = 2; i < n; i++) {
        if (isPrim(i)) count++;
    }
    return count;
}

// 判断正数n是否为素数
// 如何用计算机思维判断一个数是否为素数：比如4，我们可以取[2,4)这个区间的是两个数2 3（因为4本身会被本身整除，1也会被任何自然数整除）来分别去计算  4%2 = 0 4%3 = 1 (ps: %为模，取余的意思) 在[2,4)中只要有一个被4取余等于0的就说明 4不是素数，所以4%2=0所以  4不是素数
// 还有就是为什么要判断[2,n)区间的，为何不判断大于n的 比如 判断4，我们用4 % 8 = 4 大于4的肯定不能被整除，所以就取[2, n)
boolean isPrime(int n) {
    for(int i = 2; i < n; i++) {
        if (n % i == 0) {
            // 有其他整除因子
            return false;
        }
    }
    return true;
}
```

**这样写的话时间复杂度 O(n^2)，问题很大。首先你用 isPrime 函数来辅助的思路就不够高效；而且就算你要用 isPrime 函数，这样实现也是存在计算冗余的。**

**先来简单说下如果你要判断一个数是不是素数，应该如何写算法**。只需稍微修改一下上面的 isPrime 代码中的 for 循环条件：

```
boolean isPrime(int n) {
    for(int i = 2; i * i <= n; i++) 
        ...
}
```

换句话说，i不需要遍历到n，而只需要到sqrt(n)即可。为什么呢，我们举个例子，假设n = 12。

```
12 = 2 × 6
12 = 3 × 4
12 = sqrt(12) × sqrt(12)
12 = 4 × 3
12 = 6 × 2
```

可以看到，后两个乘积就是前面两个反过来，反转的分界点就在sqrt(n)。

换句话说，如果在[2,sqrt(n)]这个区间之内没有发现可整除因子，就可以直接断定n是素数了，因为在区间[sqrt(n),n]也一定不会发现可整除因子。

这样，**isPrime函数的时间复杂度降为了 O(sqrt(N))，**但是我们实现countPrimes函数其实并不需要这个函数，以上只是希望读者明白sqrt(n)的含义，因为等会还会用到。

### 高效实现 countPrimes

高效解决这个问题的核心思路是和上面的常规思路反着来：

首先从 2 开始，我们知道 2 是一个素数，那么 2 × 2 = 4, 3 × 2 = 6, 4 × 2 = 8… 都不可能是素数了。

然后我们发现 3 也是素数，那么 3 × 2 = 6, 3 × 3 = 9, 3 × 4 = 12… 也都不可能是素数了。

看到这里，你是否有点明白这个排除法的逻辑了呢？先看我们的第一版代码：

```
int countPrimes(int n) {
    boolean isPrim = new boolean[n];
    // 将数组都初始化为true
    Arrays.fill(isPrim, true);
    for(int i = 2; i < n; i++) {
        if (isPrim[i])
            // i的倍数不可能是素数了
            // 计算倍数，比如i为2，j从4开始，然后4 6 8 10
            // 因为2*2 2*3 2*4这都是2的倍数
            for(int j = 2*i; j < n; j += i)
                isPrim[j] = false;
    }
    int count = 0;
    for(int i = 2; i < n; i++)
        if (isPrim[i]) count++;
    return count;
}
```

![](1-1.gif)

首先，回想刚才判断一个数是否是素数的isPrime函数，由于因子的对称性，其中的 for 循环只需要遍历[2,sqrt(n)]就够了。这里也是类似的，我们外层的 for 循环也只需要遍历到sqrt(n)：

```
// 确实如果从i=2开始，对于每个i求其倍数，会重复很多，这样我们从[2, sqrt[n]]范围内足以
for(int i = 2; i * i < n; i++) {
    if (isPrim[i])
        ...
}
```

除此之外，很难注意到内层的 for 循环也可以优化。我们之前的做法是：

```
for(int j = 2 * i; j < n; j += i) {
    isPrim[j] = false;
}
```

这样可以把i的整数倍都标记为false，但是仍然存在计算冗余。

比如i = 4时算法会标记 4 × 2 = 8，4 × 3 = 12 等等数字，但是 8 和 12 已经被i = 2和i = 3的 2 × 4 和 3 × 4 标记过了。

我们可以稍微优化一下，让j从i的平方开始遍历，而不是从2 * i开始：

```
for(int j = i * i; j < n; j += i) {
    isPrim[j] = false;
}
```

这样，素数计数的算法就高效实现了。其实这个算法有一个名字，叫做 Sieve of Eratosthenes。看下完整的最终代码：

```
int countPrimes(int n) {
    boolean[] isPrim = new boolean[n];
    // 将数组都填充为true
    Arrays.fill(isPrim, true);
    // 外层、内层循环：从[2,n)将每个数的倍数置为false,因为2的倍数2*2 2*3这样子的都不是素数
    // 因子对称性：比如12 sqrt(12)为3.4.... 这时候 2 *6 = 12  3*4=12 sqrt(12)*sqrt(12)=12 4*3=12 6*2=12所以只需要计算sqrt(12)之前的的即可后面是有重复的情况
    // 因为因子的对称性，所以我们第一层循环的时候，我们只需要[2, sqrt(n)]即可
    for(int i = 2; i * i < n; i++) {
        if (isPrim[i]) {
            for(int j = i * i; j < n; j += i) {
                isPrim[j] = false;
            }
        }
    }
    
    int count = 0;
    for(int i = 2; i < n; i++)
        if (isPrim[i]) count++;
    return count;
}
```

该算法的时间复杂度比较难算，显然时间跟这个嵌套 for 循环有关，其操作数应该是：

n/2 + n/3 + n/5 + n/7 + …
= n × (1/2 + 1/3 + 1/5 + 1/7…)

括号中是素数的倒数和。其最终结果是 O(N * loglogN)，有兴趣的读者可以查一下该算法的时间复杂度证明。

以上就是素数算法相关的全部内容。怎么样，是不是看似简单的问题却有不少细节可以打磨呀？