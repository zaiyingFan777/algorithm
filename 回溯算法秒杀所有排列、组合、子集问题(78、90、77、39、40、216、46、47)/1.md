### 回溯算法秒杀所有排列、组合、子集问题(参考链接：https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247496080&idx=1&sn=a2ae8c8ebf13c7ea704ffb6b16018f08&scene=21#wechat_redirect)

> 读完本文可以解决：78. 子集（Medium) 90. 子集 II（Medium） 77. 组合（Medium） 39. 组合总和（Medium） 40. 组合总和 II（Medium） 216. 组合总和 III（Medium） 46. 全排列（Medium） 47. 全排列 II（Medium）

虽然这几个问题是高中就学过的，但如果想编写算法决这几类问题，还是非常考验计算机思维的，本文就讲讲编程解决这几个问题的核心思路，以后再有什么变体，你也能手到擒来，以不变应万变。

无论是排列、组合还是子集问题，简单说无非就是让你从序列nums中以给定规则取若干元素，主要有以下几种变体：

**形式一、元素无重不可复选，即nums中的元素都是唯一的，每个元素最多只能被使用一次，这也是最基本的形式**。

以组合为例，如果输入nums = [2,3,6,7]，和为 7 的组合应该只有[7]。

**形式二、元素可重不可复选，即nums中的元素可以存在重复，每个元素最多只能被使用一次**。

以组合为例，如果输入nums = [2,5,2,1,2]，和为 7 的组合应该有两种[2,2,2,1]和[5,2]。

**形式三、元素无重可复选，即nums中的元素都是唯一的，每个元素可以被使用若干次**。

以组合为例，如果输入nums = [2,3,6,7]，和为 7 的组合应该有两种[2,2,3]和[7]。

**当然，也可以说有第四种形式，即元素可重可复选。但既然元素可复选，那又何必存在重复元素呢？元素去重之后就等同于形式三，所以这种情况不用考虑**。

上面用组合问题举的例子，但排列、组合、子集问题都可以有这三种基本形式，所以共有 9 种变化。

除此之外，题目也可以再添加各种限制条件，比如让你求和为target且元素个数为k的组合，那这么一来又可以衍生出一堆变体，怪不得面试笔试中经常考到排列组合这种基本题型。

**但无论形式怎么变化，其本质就是穷举所有解，而这些解呈现树形结构，所以合理使用回溯算法框架，稍改代码框架即可把这些问题一网打尽**。

具体来说，你需要先阅读并理解前文 回溯算法核心套路，然后记住如下子集问题和排列问题的回溯树，就可以解决所有排列组合子集相关的问题：

![](1-1.jpg)

![](1-2.jpg)

为什么只要记住这两种树形结构就能解决所有相关问题呢？

**首先，组合问题和子集问题其实是等价的，这个后面会讲；至于之前说的三种变化形式，无非是在这两棵树上剪掉或者增加一些树枝罢了**。

那么，接下来我们就开始穷举，把排列/组合/子集问题的 9 种形式都过一遍，学学如何用回溯算法把它们一套带走。

### 子集（元素无重不可复选）

力扣第 78 题「子集」就是这个问题：

题目给你输入一个无重复元素的数组nums，其中每个元素最多使用一次，请你返回nums的所有子集。

函数签名如下：

```
List<List<Integer>> subsets(int[] nums)
```

比如输入nums = [1,2,3]，算法应该返回如下子集：

```
[ [],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3] ]
```

好，我们暂时不考虑如何用代码实现，先回忆一下我们的高中知识，如何手推所有子集？

首先，生成元素个数为 0 的子集，即空集[]，为了方便表示，我称之为S_0。

然后，在S_0的基础上生成元素个数为 1 的所有子集，我称为S_1：

![](1-3.jpg)

接下来，我们可以在S_1的基础上推导出S_2，即元素个数为 2 的所有子集：

![](1-4.jpg)

为什么集合[2]只需要添加3，而不添加前面的1呢？

因为集合中的元素不用考虑顺序，[1,2,3]中2后面只有3，如果你向前考虑1，那么[2,1]会和之前已经生成的子集[1,2]重复。

**换句话说，我们通过保证元素之间的相对顺序不变来防止出现重复的子集。**

接着，我们可以通过S_2推出S_3，实际上S_3中只有一个集合[1,2,3]，它是通过[1,2]推出的。

整个推导过程就是这样一棵树：

![](1-5.jpg)

注意这棵树的特性：

**如果把根节点作为第 0 层，将每个节点和根节点之间树枝上的元素作为该节点的值，那么第n层的所有节点就是大小为n的所有子集**。

你比如大小为 2 的子集就是这一层节点的值：

![](1-6.jpg)

> PS：注意，本文之后所说「节点的值」都是指节点和根节点之间树枝上的元素，且将根节点认为是第 0 层。

那么再进一步，如果想计算所有子集，那只要遍历这棵多叉树，把所有节点的值收集起来不就行了？

直接看代码：

```
List<List<Integer>> res = new LinkedList<>();

// 记录回溯算法的递归路径
LinkedList<Integer> track = new LinkedList<>();

// 主函数
public List<List<Integer>> subsets(int[] nums) {
    backtrack(nums, 0);
    return res;
}

// 回溯算法核心函数，遍历子集问题的回溯树
void backtrack(int[] nums, int start) {
    // 前序位置，每个节点的值都是一个子集
    res.add(new LinkedList<>(track));
    
    // 回溯算法标准框架
    for(int i = start; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        // 通过start参数控制树枝的遍历，避免产生重复的子集
        backtrack(nums, i + 1);
        // 撤销选择
        track.removeLast();
    }
}
```

最后，backtrack函数开头看似没有 base case，会不会进入无限递归？

其实不会的，当start == nums.length时，叶子节点的值会被装入res，但 for 循环不会执行，也就结束了递归。

