<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

</body>
<script>
  // 剑指 Offer 10- I. 斐波那契数列
  // 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
  // F(0) = 0,   F(1) = 1
  // F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
  // 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
  // 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

  // 示例 1：
  // 输入：n = 2
  // 输出：1

  // 示例 2：
  // 输入：n = 5
  // 输出：5

  // 提示：
  // 0 <= n <= 100

  // 解法a(自顶向下)
  // 时间复杂度太高 O(2^n)，（指数级别 可以画出来树结构！！！！！）
  // var fib = function(n) {
  //   if (n < 2) return n;
  //   return fib(n - 1) + fib(n - 2);
  // };

  // 2.带备忘录的递归解法(⾃顶向下)
  // 时间复杂度O(N)，空间复杂度O(N)
  // 解法a耗时原因是重复计算，那么我们可以造一个备忘录，每次计算出某个子问题的答案后别着急返回，先记到【备忘录】里再返回，每次遇到一个子问题先去【备忘录】里查一下，
  // 如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时区计算了。
  // 一般使用一个数组充当这个备忘录，当然你也可以使用哈希表（字典），思想都是一样的
  // 0 1 1 2 3 5 8
  // 0 1 2 3 4 5 6
  var fib = function (n) {
    if (n < 1) return 0;
    // 备忘录全初始化为0
    var memo = new Array(n + 1).fill(0); // 数组长度为n+1，方便计算，因为我们是从0开始的，这样我们找第n个数，就可以直接找memo[n]
    // 初始化最简情况
    return helper(memo, n);
  }

  function helper(memo, n) {
    // base case
    if (n === 1 || n === 2) return 1;
    // 已经计算过，直接返回
    if (memo[n] != 0) return memo[n];
    // 递归
    memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
    return memo[n];
  }


  // 啥叫「⾃顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延 伸，都是从⼀个规模较⼤的原问题⽐如说 f(20) ，向下逐渐分解规模，
  // 直 到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「⾃顶向下」。
  // 啥叫「⾃底向上」？反过来，我们直接从最底下，最简单，问题规模最⼩的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20) ，
  // 这就是动 态规划的思路，这也是为什么动态规划⼀般都脱离了递归，⽽是由循环迭代 完成计算。

  // 3.dp数组的迭代解法(自底而上的动态规划)
  // 有了上⼀步「备忘录」的启发，我们可以把这个「备忘录」独⽴出来成为⼀ 张表，就叫做 DP table 吧，在这张表上完成「⾃底向上」的推算岂不美哉！
  var fib = function (n) {
    // 初始化dp数组
    // [0, 1, 1, 2, 3, 5, 8]
    //  0  1  2  3  4  5  6
    var dp = new Array(n + 1).fill(0); // 数组长度为n+1，方便计算，因为我们是从0开始的，这样我们找第n个数，就可以直接找dp[n]
    dp[1] = dp[2] = 1;
    for (var i = 3; i <= n; i++) {
      dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
  }

  // 这⾥，引出「状态转移⽅程」这个名词，实际上就是描述问题结构的数学形式
  // f(n) ={ 1, n = 1, 2
  //       { f(n-1) + f(n-2), n > 2
  // 为啥叫「状态转移⽅程」？为了听起来⾼端。你把 f(n) 想做⼀个状态 n，这 个状态 n 是由状态 n - 1 和状态 n - 2 相加转移⽽来，这就叫状态转移，仅此 ⽽已。

  // !!!!优化
  // 根据斐波那契数列 的状态转移⽅程，当前状态只和之前的两个状态有关，其实并不需要那么⻓的⼀个 DPtable 来存储所有的状态，只要想办法存储之前的两个状态就⾏了。
  // 所以，可以进⼀步优化，把空间复杂度降为 O(1)

  // 解题方案
  // 思路 1
  // 1.标签：动态规划(⾃底向上)
  // 2.本题是经典的动态规划问题，围绕斐波那契数列方程 F(n+1) = F(n) + F(n−1) 进行解题，所以在求 n+1 元素时，只需要知道第 n 和 n-1 个元素即可
  // 2a.状态定义： F[n] 表示的含义为斐波那契数列中第 n 个数字
  // 2b.转移方程： F(n+1) = F(n) + F(n−1) ，所以在求 n+1 元素时，只需要知道第 n 和 n-1 个元素即可，故而运算过程中不需要保存数组
  // 2c.初始状态： F[0] = 0, F[1] = 1 ，因为在计算 n+1 时需要 2 个元素，所以要初始化 2 个值；
  // 3.其中取模 1000000007 运算主要是为了避免数字溢出，这步运算在每次计算出新的斐波那契数时进行即可，因为模运算的特性，后续再进行加法运算也不会有任何影响
  // 4.模运算特性：(x + y) % z = ((x % z) + (y % z)) % z
  // 5.时间复杂度：O(n)，空间复杂度：O(1)

  /**
   * @param {number} n
   * @return {number}
   */
  // 0 1 1 2 3 5 8
  // n1，n2两个滑块，n就是执行n次往后滑动，然后返回n1即可
  var fib = function (n) {
    var num1 = 0,
      num2 = 1,
      sum;
    for (var i = 0; i < n; i++) {
      // 由f(n+1) = f(n) + f(n-1)得到的sum
      sum = (num1 + num2) % 1000000007;
      // 将n1 n2向下顺延一位
      [num1, num2] = [num2, sum];
    }
    return num1;
  };
</script>

</html>