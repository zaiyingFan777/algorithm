<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
</body>
<script>
  // 剑指 Offer 10- I. 斐波那契数列
  // 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
  // F(0) = 0,   F(1) = 1
  // F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
  // 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
  // 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

  // 示例 1：
  // 输入：n = 2
  // 输出：1

  // 示例 2：
  // 输入：n = 5
  // 输出：5

  // 提示：
  // 0 <= n <= 100

  // 时间复杂度太高 O(2^n)，（指数级别 可以画出来树结构！！！！！）
  // var fib = function(n) {
  //   if (n < 2) return n;
  //   return fib(n - 1) + fib(n - 2);
  // };

  // 解题方案
  // 思路 1
  // 1.标签：动态规划
  // 2.本题是经典的动态规划问题，围绕斐波那契数列方程 F(n+1) = F(n) + F(n−1) 进行解题，所以在求 n+1 元素时，只需要知道第 n 和 n-1 个元素即可
  // 2a.状态定义： F[n] 表示的含义为斐波那契数列中第 n 个数字
  // 2b.转移方程： F(n+1) = F(n) + F(n−1) ，所以在求 n+1 元素时，只需要知道第 n 和 n-1 个元素即可，故而运算过程中不需要保存数组
  // 2c.初始状态： F[0] = 0, F[1] = 1 ，因为在计算 n+1 时需要 2 个元素，所以要初始化 2 个值；
  // 3.其中取模 1000000007 运算主要是为了避免数字溢出，这步运算在每次计算出新的斐波那契数时进行即可，因为模运算的特性，后续再进行加法运算也不会有任何影响
  // 4.模运算特性：(x + y) % z = ((x % z) + (y % z)) % z
  // 5.时间复杂度：O(n)，空间复杂度：O(1)

  /**
   * @param {number} n
   * @return {number}
   */
  // 0 1 1 2 3 5 8
  // n1，n2两个滑块，n就是执行n次往后滑动，然后返回n1即可
  var fib = function(n) {
    var num1 = 0, num2 = 1, sum;
    for(var i = 0; i < n; i++) {
      // 由f(n+1) = f(n) + f(n-1)得到的sum
      sum = (num1 + num2) % 1000000007;
      // 将n1 n2向下顺延一位
      [num1, num2] = [num2, sum];
    }
    return num1;
  };
</script>
</html>