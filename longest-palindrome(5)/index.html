<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

</body>
<script>
  // 5. 最长回文子串
  // 给你一个字符串 s， 找到 s 中最长的回文子串。

  // 示例 1：
  // 输入： s = "babad"
  // 输出： "bab"
  // 解释： "aba"
  // 同样是符合题意的答案。

  // 示例 2：
  // 输入： s = "cbbd"
  // 输出： "bb"

  // 提示：

  // 1 <= s.length <= 1000
  // s 仅由数字和英文字母组成


  // string.substr(start,length)
  // var a = 'abcde'; a.substr(0) => 'abcde'; a.substr(1) => 'bcde';
  // a.substr(1,2) => 'bc'

  /**
   * @param {string} s
   * @return {number}
   */
  var longestPalindrome = function (s) {
    // 寻找长度
    // var res = 0;
    // 寻找最长的字串
    var res = "";
    // 定义寻找回文串的方法
    var palindrome = function (s, l, r) {
      // i,j的边界
      while (l >= 0 && r < s.length && s[l] === s[r]) {
        // 向两边展开
        l--;
        r++;
      }
      // 返回以s[l]和s[r]为中心的最长回文串，如果没有返回""
      return s.substr(l + 1, r - l - 1); // 起点得为i+1，因为i--了，但是又不满足条件 j - (i+1)
    }
    // 挨个遍历字符串元素，找到以s[i]为中心的回文字串和s[i]s[i+1]为中心的回文串，然后找出最大的。
    for (var i = 0; i < s.length; i++) {
      // 以s[i]为中心的最长回文字串（长度为奇数）
      var s1 = palindrome(s, i, i);
      // 以s[i]、s[i+1]为中心的最长回文字串（长度为偶数）
      var s2 = palindrome(s, i, i + 1);
      // 寻找长度
      // res = Math.max(res, s1.length, s2.length);
      // 寻找最长的字串
      res = res.length > s1.length ? res : s1;
      res = res.length > s2.length ? res : s2;
    }
    return res;
  };
</script>

</html>