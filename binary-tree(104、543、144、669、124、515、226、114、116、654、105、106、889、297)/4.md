## 二叉树（序列化篇）（参考链接：https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247496591&idx=1&sn=d56c42ee940e4b651b644f9d36eba829&scene=21#wechat_redirect）

本文是承接 二叉树（纲领篇） 的第三篇文章，前文 二叉树（构造篇） 带你学习了二叉树构造技巧，本文加大难度，让你对二叉树同时进行「序列化」和「反序列化」。

要说序列化和反序列化，得先从 JSON 数据格式说起。

JSON 的运用非常广泛，比如我们经常将变成语言中的结构体序列化成 JSON 字符串，存入缓存或者通过网络发送给远端服务，消费者接受 JSON 字符串然后进行反序列化，就可以得到原始数据了。

这就是序列化和反序列化的目的，以某种特定格式组织数据，使得数据可以独立于编程语言。

那么假设现在有一棵用 Java 实现的二叉树，我想把它通过某些方式存储下来，然后用 C++ 读取这棵并还原这棵二叉树的结构，怎么办？这就需要对二叉树进行序列化和反序列化了。

直接看题吧。

### 一、题目描述

力扣第 297 题「二叉树的序列化与反序列化」就是给你输入一棵二叉树的根节点root，要求你实现如下一个类：

```
public class Codec {

  // 把一棵二叉树序列化成字符串
  public String serialize(TreeNode root) {}

  // 把字符串反序列化成二叉树
  public TreeNode deserialize(String data) {}
}
```