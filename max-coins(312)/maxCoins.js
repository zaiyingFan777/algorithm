// 312. 戳气球
// 有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。
// 现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。
// 求所能获得硬币的最大数量。

// 示例 1：
// 输入：nums = [3,1,5,8]
// 输出：167
// 解释：
// nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
// coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167

// 示例 2：
// 输入：nums = [1,5]
// 输出：10

// 提示：

// n == nums.length
// 1 <= n <= 300
// 0 <= nums[i] <= 100

// 在一排气球points中，请你戳破气球0和气球n+1之间的所有气球（不包括0和n+1），使得最终只剩下气球0和气球n+1两个气球，最多能够得到多少分？
// dp[i][j] = x表示，戳破气球i和气球j之间（开区间，不包括i和j）的所有气球，可以获得的最高分数为x。
// 其实气球i和气球j之间的所有气球都可能是最后被戳破的那一个，不防假设为k。回顾动态规划的套路，这里其实已经找到了「状态」和「选择」：i和j就是两个「状态」，最后戳破的那个气球k就是「选择」。
// 根据刚才对dp数组的定义，如果最后一个戳破气球k，dp[i][j]的值应该为：
// dp[i][j] = dp[i][k] + dp[k][j] 
//          + points[i]*points[k]*points[j]
// 你不是要最后戳破气球k吗？那得先把开区间(i, k)的气球都戳破，再把开区间(k, j)的气球都戳破；最后剩下的气球k，相邻的就是气球i和气球j，这时候戳破k的话得到的分数就是points[i]*points[k]*points[j]。
// 那么戳破开区间(i, k)和开区间(k, j)的气球最多能得到的分数是多少呢？嘿嘿，就是dp[i][k]和dp[k][j]，这恰好就是我们对dp数组的定义嘛！
// 由于是开区间，dp[i][k]和dp[k][j]不会影响气球k；而戳破气球k时，旁边相邻的就是气球i和气球j了，最后还会剩下气球i和气球j，这也恰好满足了dp数组开区间的定义


// base case: 就是dp[i][j] = 0，其中0 <= i <= n+1, j <= i+1，因为这种情况下，开区间(i, j)中间根本没有气球可以戳。
// base case: i = j dp[i][j] = 0
// 0 x x x x
// 0 0 x x x
// 0 0 0 x x 
// 0 0 0 0 x
// 0 0 0 0 0   类似于这个图，i = j中间没气球可戳，i > j也没有气球可戳

/**
 * @param {number[]} nums
 * @return {number}
 */
var maxCoins = function(nums) {
  var n = nums.length;
  // 重新定义nums，将-1和n+1放到数组中
  var points = new Array(n+2).fill(0);
  // 第一个以及第n+1
  points[0] = points[n+1] = 1;
  // 将nums元素放到points中
  for(var i = 1; i <= n; i++) {
    points[i] = nums[i-1];
  }
  // 定义dp  base case已经定义
  var dp = new Array(n+2).fill(null).map(() => new Array(n+2).fill(0));
  // 循环斜着见md文件，
  // 从下到上，从左到右
  for(var i = n; i >= 0; i--) { // i = n+1 j = n+2这种情况不存在，所以从i = n开始
    for(var j = i+1; j < n + 2; j++) { // j <= n+1
      // 最后戳破得气球是哪个？
      for(var k = i+1; k < j; k++) {
        // 转移方程
        dp[i][j] = Math.max(
          dp[i][j],
          // K是最后一个被戳破的气球，所有遍历i+1到j-1之间的所有k输出dp[i][j]最大值  这个dp[i][j]会被不同的k计算不通的值，取最大值
          dp[i][k] + dp[k][j] + points[i]*points[k]*points[j] // 戳破i-k 以及 k-j 只剩下 i, j, k相连了
        )
      }
    }
  }
  // 两边取不到
  return dp[0][n+1];
};