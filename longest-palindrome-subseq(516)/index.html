<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

</body>
<script>
  // 516. 最长回文子序列
  // 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。
  // 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

  // 示例 1：
  // 输入：s = "bbbab"
  // 输出：4
  // 解释：一个可能的最长回文子序列为 "bbbb" 。

  // 示例 2：
  // 输入：s = "cbbd"
  // 输出：2
  // 解释：一个可能的最长回文子序列为 "bb" 。

  // 提示：
  // 1 <= s.length <= 1000
  // s 仅由小写英文字母组成

  // 一、dp table
  // 1.状态：这里选择二维数组，因为如果我们想求dp[i][j]，我们知道了子问题dp[i+1][j-1]的结果（s[i+1..j-1]中最长回文子序列的长度），接下来在选择中继续解释
  // 在字串s[i..j]中，最长回文子序列的长度为dp[i][j]
  // 2.选择：如果s[i]和s[j]的字符相等，那么它俩加上s[i+1..j-1]中的最长回文字串序列就是s[i..j]的最长序列，如果他俩不相等，说名他俩
  // 不可能同时出现在s[i..j]的最长回文字串，那么把他俩分别加入s[i+1..j-1]中看哪个更长。
  // 3.base case: 我们创建一个跟字符串(s.length)长度同等的二维数组 dp[n][n]，当i等于j的时候dp[i][j] = 1，当i大于j的时候,dp[i][j]为0，因为i必须小于等于j
  // 由于我们求的dp[i][j]，我们需要知道dp[i][j-1](左) dp[i+1][j-1](左下)dp[i+1][j]（下）共同推出来的，所以可以斜着遍历或者反着遍历

  /**
   * @param {string} s
   * @return {number}
   */
  var longestPalindromeSubseq = function (s) {
    // 构建dp数组，我们默认为0，因为base case中i<j的时候为0，就不用再故意设置这些默认值
    var dp = new Array(s.length).fill(null).map(() => new Array(s.length).fill(0));
    // 当i==j的时候，dp[i][j]为1
    for (var i = 0; i < s.length; i++) {
      dp[i][i] = 1;
    }
    // dp[i][j]代表了s[i..j]的最长回文子序列的长度，所以最后需要返回的是s[0,s.length-1]
    // 这里我们反着遍历(i从n-1到0，j从i到N-1，因为j必须大于i，否则没意义) ↑(i)→(j)
    for (var i = s.length - 1; i >= 0; i--) {
      for (var j = i + 1; j < s.length; j++) {
        if (s[i] === s[j]) {
          // 如果s[i]与s[j]相等，相当于回文子序列多了两个元素
          dp[i][j] = dp[i+1][j-1] + 2;
        } else {
          // 如果s[i]与s[j]不相等，那就是从s[i-1, j]和s[i, j-1]找最大值
          dp[i][j] = Math.max(
            dp[i][j-1], // 左
            dp[i+1][j], // 下
          )
        }
      }
    }
    // 整个 s 的最长回文子串长度
    return dp[0][s.length - 1];
  };
</script>

</html>