// 37. 解数独
// 编写一个程序，通过填充空格来解决数独问题。
// 数独的解法需 遵循如下规则：
// 数字 1-9 在每一行只能出现一次。
// 数字 1-9 在每一列只能出现一次。
// 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
// 数独部分空格内已填入了数字，空白格用 '.' 表示。
//
// 示例 1：
// 输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
// 输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
// 解释：输入的数独如上图所示，唯一有效的解决方案如下所示：
//
// 提示：
// board.length == 9
// board[i].length == 9
// board[i][j] 是一位数字或者 '.'
// 题目数据 保证 输入数独仅有一个解

// 思路：回溯，我们对每个棋盘的位置从'1'到'9'尝试然后再进行子树的尝试，回溯完毕会找到所有解法，所以为了程序运行更快，我们只需要找出一个结果return true即可
// base case: 当j == 9的时候，需要换行 (i+1, 0) 如果我们遇到非'.'的时候，我们需要去下一列尝试 (i, j+1)，如果我们的i==9说明我们找到了一个结果 return true

/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solveSudoku = function(board) {
  // m为行
  var m = board.length;
  // n为列
  var n = board[0].length;
  // 检查是否符合
  // 1.同一行没有重复的，2.同一列没有重复的 3.从这个点开始的九宫格是否有重复的（当然越界的我们会考虑，undefined肯定不等于具体的值）
  // r: 行， c: 列 ch就是被选择的字符
  var isValid = function (board, r, c, n) {
    // 循环条件为 0-8因为我们要从每一行或每一列挨个去找是否与n相等
    for(var i = 0; i < 9; i++) {
      // 同一行是否有重复项
      if (board[r][i] === n) return false;
      // 同一列是否有重复
      if (board[i][c] === n) return false;
      // 九宫格，board[r][c]开始的九宫格
      // 这里关于除法都带上Math.floor
      if (board[Math.floor((r/3))*3 + Math.floor(i/3)][Math.floor((c/3))*3 + i%3] === n) return false;
    }
    return true;
  }
  // 回溯算法
  var backtrack = function (board, i, j) {
    // base case 如果j为n，说明我们需要换行
    if (j === n) {
      // 因为我们只需要找出来一个结果，所以用return，如果是找所有的结果没必要return
      return backtrack(board, i + 1, 0);
    }
    // base case 如果i为m，说明我们找到了结果
    if (i === m) return true;
    // base case 如果board[i][j]不为'.'跳过
    if (board[i][j] !== '.') {
      return backtrack(board, i, j + 1);
    }
    for(var ch = 1; ch <= 9; ch++) {
      // 如果不合法跳过
      if (!isValid(board, i, j, ch.toString())) continue;
      // 做选择
      board[i][j] = ch.toString();
      // 如果有合适的结果直接返回true，停止回溯
      // 这里有个技巧,在if条件里递归操作，同样道理 也会一直递归，直到backtrack的true或者false
      if (backtrack(board, i, j+1)) {
        return true;
      }
      // 撤销选择
      board[i][j] = '.';
    }
    // 遍历完'1'到'9'没有合适的
    return false; // 这时候返回false,就会在前一次递归中的循环撤销选择，然后再循环下一轮
  }
  // 递归开始
  backtrack(board, 0, 0);
};